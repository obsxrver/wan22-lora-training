<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WAN 2.2 LoRA Training</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #121212;
        --panel: #1f1f1f;
        --accent: #8ab4f8;
        --accent-strong: #a66bff;
        --border: #2a2a2a;
        --text: #f1f3f4;
        --muted: #9aa0a6;
      }

      body {
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        margin: 0;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
        overflow-x: hidden;
      }

      header {
        padding: 2rem 1.5rem 1rem;
        text-align: center;
        background: linear-gradient(135deg, rgba(138, 180, 248, 0.25), rgba(166, 107, 255, 0.25));
        border-bottom: 1px solid var(--border);
      }

      header h1 {
        margin: 0 0 0.5rem;
        font-size: 2rem;
      }

      header p {
        margin: 0;
        color: var(--muted);
      }

      .header-text {
        max-width: 640px;
        margin: 0 auto;
      }

      header .top-nav {
        margin-top: 1.25rem;
        display: flex;
        justify-content: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .nav-link {
        display: inline-flex;
        align-items: center;
        padding: 0.6rem 1.2rem;
        border-radius: 999px;
        text-decoration: none;
        font-weight: 600;
        color: var(--text);
        border: 1px solid transparent;
        background: rgba(138, 180, 248, 0.15);
        transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
      }

      .nav-link:hover {
        border-color: rgba(138, 180, 248, 0.4);
        background: rgba(138, 180, 248, 0.25);
      }

      .nav-link--active {
        border-color: rgba(166, 107, 255, 0.5);
        background: rgba(166, 107, 255, 0.3);
      }

      main {
        max-width: 1100px;
        margin: 0 auto;
        padding: 1.5rem;
        display: grid;
        gap: 1.5rem;
      }

      section {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      }

      h2 {
        margin-top: 0;
        font-size: 1.35rem;
      }

      #dropzone {
        border: 2px dashed var(--accent);
        border-radius: 16px;
        padding: 2rem;
        text-align: center;
        transition: background 0.2s ease, border-color 0.2s ease;
        cursor: pointer;
        color: var(--muted);
        font-size: 1rem;
        outline: none;
      }

      #dropzone.active {
        background: rgba(138, 180, 248, 0.12);
        border-color: var(--accent-strong);
        color: var(--text);
      }

      #dropzone:focus-visible {
        border-color: var(--accent-strong);
        box-shadow: 0 0 0 3px rgba(138, 180, 248, 0.25);
        color: var(--text);
      }

      #fileInput {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        border: 0;
        clip: rect(0, 0, 0, 0);
        overflow: hidden;
      }

      #upload-summary {
        margin-top: 1rem;
        font-size: 0.95rem;
        color: var(--muted);
      }

      #dataset-preview-section {
        margin-top: 1.5rem;
      }

      .dataset-preview-collapsible {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 0.75rem 1rem 1rem;
        background: rgba(255, 255, 255, 0.04);
      }

      .dataset-preview-collapsible summary {
        list-style: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.25rem 0;
      }

      .dataset-preview-collapsible summary::-webkit-details-marker {
        display: none;
      }

      .dataset-preview-collapsible summary:focus-visible {
        outline: 2px solid rgba(138, 180, 248, 0.6);
        border-radius: 8px;
      }

      .dataset-preview-collapsible summary::after {
        content: '▾';
        font-size: 0.9rem;
        margin-left: auto;
        color: var(--muted);
        transition: transform 0.2s ease;
      }

      .dataset-preview-collapsible[open] summary::after {
        transform: rotate(180deg);
      }

      .dataset-preview-collapsible h3 {
        margin: 0;
        font-size: 1.1rem;
      }

      .dataset-preview-hint {
        margin: 0.5rem 0 1rem;
        font-size: 0.85rem;
        color: var(--muted);
      }

      #dataset-preview-message {
        margin-top: 0.75rem;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .dataset-grid {
        margin-top: 1rem;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 1rem;
      }

      .dataset-card {
        border: 1px solid var(--border);
        border-radius: 12px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.04);
        display: flex;
        flex-direction: column;
        min-height: 100%;
        position: relative;
        transition: opacity 0.2s ease, transform 0.2s ease;
      }

      .dataset-card--removing {
        opacity: 0.5;
        pointer-events: none;
      }

      .dataset-card-actions {
        position: absolute;
        top: 0.6rem;
        right: 0.6rem;
        display: flex;
        gap: 0.35rem;
        z-index: 1;
      }

      .dataset-card-actions button {
        appearance: none;
        border: 1px solid rgba(138, 180, 248, 0.25);
        background: rgba(18, 18, 18, 0.65);
        color: var(--text);
        border-radius: 8px;
        padding: 0.2rem 0.55rem;
        font-size: 0.75rem;
        line-height: 1.2;
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease;
      }

      .dataset-card-actions button:hover,
      .dataset-card-actions button:focus-visible {
        border-color: rgba(138, 180, 248, 0.5);
        background: rgba(138, 180, 248, 0.3);
        outline: none;
      }

      .dataset-card-actions button:disabled {
        opacity: 0.6;
        cursor: progress;
      }

      .dataset-card-media {
        width: 100%;
        height: 180px;
        object-fit: cover;
        background: rgba(0, 0, 0, 0.35);
        display: block;
      }

      .dataset-card video.dataset-card-media {
        object-fit: cover;
        width: 100%;
        height: 100%;
      }

      .dataset-card-body {
        padding: 0.9rem;
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
      }

      .dataset-card-caption-wrapper {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }

      .dataset-card-title {
        margin: 0;
        font-weight: 600;
        font-size: 0.95rem;
        color: var(--text);
        word-break: break-word;
      }

      .dataset-card-meta {
        margin: 0;
        font-size: 0.75rem;
        color: var(--muted);
        word-break: break-word;
      }

      .dataset-card-caption {
        margin: 0;
        font-size: 0.85rem;
        color: var(--muted);
        white-space: pre-wrap;
      }

      .dataset-card-caption--empty {
        font-style: italic;
      }

      .dataset-card-caption-editor {
        display: none;
        width: 100%;
        min-height: 80px;
        padding: 0.5rem 0.65rem;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.45);
        color: var(--text);
        font-family: inherit;
        font-size: 0.85rem;
        resize: vertical;
      }

      .dataset-card--editing .dataset-card-caption {
        display: none;
      }

      .dataset-card--editing .dataset-card-caption-editor {
        display: block;
      }

      form {
        display: grid;
        gap: 1rem;
      }

      .form-row {
        display: grid;
        gap: 1rem;
      }

      .form-row.two-col {
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      label {
        display: flex;
        flex-direction: column;
        font-weight: 600;
        color: var(--muted);
        gap: 0.4rem;
      }

      a {
        color: var(--accent);
        text-decoration: none;
      }

      a:hover {
        color: var(--accent-strong);
      }

      input[type="text"],
      input[type="number"] {
        padding: 0.6rem 0.75rem;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        font-size: 0.95rem;
      }

      input[type="checkbox"] {
        width: 1.1rem;
        height: 1.1rem;
        accent-color: var(--accent);
      }

      input[type="radio"] {
        width: 1rem;
        height: 1rem;
        accent-color: var(--accent);
      }

      .mode-fieldset {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 1rem 1.25rem;
        background: rgba(255, 255, 255, 0.04);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .mode-fieldset legend {
        padding: 0 0.35rem;
        font-weight: 700;
        color: var(--text);
      }

      .mode-options {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
      }

      .mode-option {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        font-weight: 600;
        color: var(--muted);
      }

      .mode-hint {
        margin: 0;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .toggle {
        display: flex;
        align-items: center;
        gap: 0.6rem;
        font-weight: 600;
        color: var(--muted);
      }

      .toggle.disabled {
        opacity: 0.5;
        pointer-events: none;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 0.8rem 1.4rem;
        font-size: 1rem;
        font-weight: 600;
        background: linear-gradient(135deg, var(--accent), var(--accent-strong));
        color: var(--text);
        cursor: pointer;
        transition: transform 0.15s ease, opacity 0.15s ease;
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      button:not(:disabled):hover {
        transform: translateY(-1px);
      }

      .button-secondary {
        background: linear-gradient(135deg, #ff8a80, #ff5252);
      }

      #status-line {
        font-size: 1rem;
        font-weight: 600;
        color: var(--accent);
      }

      #message {
        color: var(--muted);
        font-size: 0.95rem;
        min-height: 1.2rem;
      }

      .metrics {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .metric-card {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 1rem;
        background: rgba(255, 255, 255, 0.03);
      }

      .metric-card--disabled {
        opacity: 0.65;
        border-style: dashed;
      }

      .status-note {
        font-size: 0.9rem;
        color: var(--muted);
      }

      #cloudStatusMessage,
      #apiKeyMessage {
        min-height: 1.2rem;
      }

      .api-key-row {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-top: 0.5rem;
      }

      .api-key-row input[type="text"] {
        flex: 1;
      }

      .button-inline {
        padding: 0.6rem 1rem;
        border-radius: 12px;
        white-space: nowrap;
      }

      .metric-card h3 {
        margin: 0 0 0.5rem;
        font-size: 1.1rem;
      }

      .metric-card p {
        margin: 0.2rem 0;
        font-size: 0.95rem;
        color: var(--muted);
      }

      .metric-status {
        margin: 0.35rem 0 0.5rem;
        font-size: 0.85rem;
        color: var(--muted);
        min-height: 1.1rem;
      }

      canvas {
        width: 100% !important;
        max-height: 320px;
      }

      #logOutput {
        background: rgba(0, 0, 0, 0.35);
        border-radius: 12px;
        border: 1px solid var(--border);
        padding: 1rem;
        max-height: 280px;
        overflow-y: auto;
        font-family: "JetBrains Mono", "Fira Code", monospace;
        font-size: 0.85rem;
        line-height: 1.45;
        white-space: pre-wrap;
      }

      @media (max-width: 768px) {
        header {
          padding: 1.5rem 1rem 1rem;
        }
        main {
          padding: 1rem;
        }
        .dataset-grid {
          grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
        }
        .dataset-card-media {
          height: 150px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-text">
        <h1>WAN 2.2 LoRA Training</h1>
        <p>Upload your dataset, configure prompts, and launch training with live feedback.</p>
      </div>
      <nav class="top-nav" aria-label="Main navigation">
        <a href="/" class="nav-link nav-link--active" aria-current="page">Training UI</a>
        <a href="/SillyCaption" class="nav-link">SillyCaption</a>
      </nav>
    </header>
    <main>
      <section>
        <h2>1. Upload dataset files</h2>
        <div id="dropzone" role="button" tabindex="0" aria-controls="upload-summary" aria-describedby="dropzone-instructions">
          <strong>Drop images, videos, and caption files here</strong>
          <div id="dropzone-instructions">or click to browse from your machine.</div>
        </div>
        <input id="fileInput" type="file" multiple />
        <div id="upload-summary">Files will be saved to /workspace/musubi-tuner/dataset/.</div>
        <div id="dataset-preview-section">
          <details class="dataset-preview-collapsible" open>
            <summary>
              <h3>Current dataset</h3>
            </summary>
            <p class="dataset-preview-hint">
              Need captions? Try the SillyCaption tool from the navigation bar to auto-generate prompts for images or videos that
              are still missing descriptions before you start training.
            </p>
            <div id="dataset-preview-message" aria-live="polite">No dataset files uploaded yet.</div>
            <div id="dataset-grid" class="dataset-grid" role="list"></div>
          </details>
        </div>
      </section>

      <section>
        <h2>2. Configure training</h2>
        <div id="status-line">Status: <span id="status">Idle</span></div>
        <div id="message"></div>
        <form id="trainingForm">
          <div class="form-row two-col">
            <label>
              Title suffix
              <input type="text" name="titleSuffix" value="mylora" required />
            </label>
            <label>
              Author
              <input type="text" name="author" value="authorName" required />
            </label>
          </div>
          <div class="form-row">
            <label>
              Dataset config path
              <input type="text" name="datasetPath" value="/workspace/musubi-tuner/dataset/dataset.toml" required />
            </label>
          </div>
          <div class="form-row">
            <fieldset class="mode-fieldset">
              <legend>Training task</legend>
              <div class="mode-options" role="radiogroup" aria-label="Training task">
                <label class="mode-option">
                  <input type="radio" name="trainingMode" value="t2v" checked />
                  <span>Text to Video (T2V)</span>
                </label>
                <label class="mode-option">
                  <input type="radio" name="trainingMode" value="i2v" />
                  <span>Image to Video (I2V)</span>
                </label>
              </div>
              <p class="mode-hint">Choose I2V to train with the image-to-video task and models.</p>
            </fieldset>
          </div>
          <div class="form-row">
            <fieldset class="mode-fieldset">
              <legend>Noise schedule</legend>
              <div class="mode-options" role="radiogroup" aria-label="Noise schedule">
                <label class="mode-option">
                  <input type="radio" name="noiseMode" value="both" checked />
                  <span>Train high and low noise (recommended)</span>
                </label>
                <label class="mode-option">
                  <input type="radio" name="noiseMode" value="high" />
                  <span>Train high noise only</span>
                </label>
                <label class="mode-option">
                  <input type="radio" name="noiseMode" value="low" />
                  <span>Train low noise only</span>
                </label>
              </div>
              <p class="mode-hint">Limit training to a single noise model if you want to save time or VRAM.</p>
            </fieldset>
          </div>
          <div class="form-row two-col">
            <label>
              Save every N epochs
              <input type="number" name="saveEvery" min="1" value="20" />
            </label>
            <label>
              CPU threads per process (leave blank for auto)
              <input type="number" name="cpuThreads" min="1" placeholder="Auto" />
            </label>
            <label>
              Max data loader workers (leave blank for auto)
              <input type="number" name="maxWorkers" min="1" placeholder="Auto" />
            </label>
          </div>
          <div class="form-row two-col">
            <label class="toggle">
              <input type="checkbox" name="uploadCloud" checked />
              Upload LoRAs to cloud storage after training
            </label>
            <label class="toggle">
              <input type="checkbox" name="shutdownInstance" checked />
              Shut down instance after training
            </label>
          </div>
          <div class="form-row">
            <label class="toggle">
              <input type="checkbox" name="convertVideos" />
              Convert dataset videos to 16 FPS before training
            </label>
          </div>
          <div id="cloudStatusMessage" class="status-note" aria-live="polite"></div>
          <div class="form-row">
            <label>
              Vast.ai API key for cloud uploads
              <span class="status-note"
                >Need a key? <a href="https://cloud.vast.ai/manage-keys" target="_blank" rel="noopener">Create one on Vast.ai</a>.</span
              >
              <div class="api-key-row">
                <input type="text" id="vastApiKeyInput" placeholder="Enter Vast.ai API key" autocomplete="off" spellcheck="false" />
                <button type="button" id="saveApiKeyButton" class="button-inline">Save key</button>
              </div>
              <div id="apiKeyMessage" class="status-note" aria-live="polite"></div>
            </label>
          </div>
          <div class="form-row two-col">
            <button id="startButton" type="submit">Start training</button>
            <button id="stopButton" type="button" class="button-secondary" disabled>Stop training</button>
          </div>
        </form>
      </section>

      <section>
        <h2>3. Live progress</h2>
        <div class="metrics">
          <div class="metric-card" id="highMetrics">
            <h3>High noise</h3>
            <p class="metric-status" id="highStatus" aria-live="polite"></p>
            <p>Current step: <span id="highStep">-</span></p>
            <p>Current loss: <span id="highLoss">-</span></p>
            <p>Epoch: <span id="highEpoch">-</span></p>
            <p>Total steps: <span id="highTotalSteps">-</span></p>
            <p>Time elapsed: <span id="highElapsed">-</span></p>
            <p>Time remaining: <span id="highEta">-</span></p>
          </div>
          <div class="metric-card" id="lowMetrics">
            <h3>Low noise</h3>
            <p class="metric-status" id="lowStatus" aria-live="polite"></p>
            <p>Current step: <span id="lowStep">-</span></p>
            <p>Current loss: <span id="lowLoss">-</span></p>
            <p>Epoch: <span id="lowEpoch">-</span></p>
            <p>Total steps: <span id="lowTotalSteps">-</span></p>
            <p>Time elapsed: <span id="lowElapsed">-</span></p>
            <p>Time remaining: <span id="lowEta">-</span></p>
          </div>
        </div>
        <canvas id="lossChart"></canvas>
      </section>

      <section>
        <h2>Training log</h2>
        <pre id="logOutput">Waiting for training output…</pre>
      </section>
    </main>

    <script
      src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"
      integrity="sha384-9nhczxUqK87bcKHh20fSQcTGD4qq5GhayNYSYWqwBkINBhOfQLg/P5HG5lF1urn4"
      crossorigin="anonymous"
    ></script>
    <script>
      const dropzone = document.getElementById('dropzone');
      const fileInput = document.getElementById('fileInput');
      const uploadSummary = document.getElementById('upload-summary');
      const datasetGrid = document.getElementById('dataset-grid');
      const datasetMessage = document.getElementById('dataset-preview-message');
      const form = document.getElementById('trainingForm');
      const statusEl = document.getElementById('status');
      const messageEl = document.getElementById('message');
      const startButton = document.getElementById('startButton');
      const highStepEl = document.getElementById('highStep');
      const highLossEl = document.getElementById('highLoss');
      const highEpochEl = document.getElementById('highEpoch');
      const highTotalStepsEl = document.getElementById('highTotalSteps');
      const highElapsedEl = document.getElementById('highElapsed');
      const highEtaEl = document.getElementById('highEta');
      const highStatusEl = document.getElementById('highStatus');
      const highCardEl = document.getElementById('highMetrics');
      const lowStepEl = document.getElementById('lowStep');
      const lowLossEl = document.getElementById('lowLoss');
      const lowEpochEl = document.getElementById('lowEpoch');
      const lowTotalStepsEl = document.getElementById('lowTotalSteps');
      const lowElapsedEl = document.getElementById('lowElapsed');
      const lowEtaEl = document.getElementById('lowEta');
      const lowStatusEl = document.getElementById('lowStatus');
      const lowCardEl = document.getElementById('lowMetrics');
      const stopButton = document.getElementById('stopButton');
      const logOutput = document.getElementById('logOutput');
      const uploadCloudCheckbox = form.querySelector('input[name="uploadCloud"]');
      const uploadCloudLabel = uploadCloudCheckbox ? uploadCloudCheckbox.closest('.toggle') : null;
      const cloudStatusMessageEl = document.getElementById('cloudStatusMessage');
      const apiKeyInput = document.getElementById('vastApiKeyInput');
      const apiKeyButton = document.getElementById('saveApiKeyButton');
      const apiKeyMessageEl = document.getElementById('apiKeyMessage');
      let currentCloudStatus = null;
      const NO_CAPTION_TEXT = 'No caption file found for this media.';

      const MAX_LOG_LINES = 400;
      const logLines = [];
      const VIDEO_EXTENSION_PATTERN = /\.(mp4|mov|avi|mkv|webm|mpg|mpeg)$/i;

      function setDatasetMessage(text = '', isError = false) {
        if (!datasetMessage) {
          return;
        }
        datasetMessage.textContent = text;
        datasetMessage.style.display = text ? 'block' : 'none';
        datasetMessage.style.color = isError ? '#ff8a80' : 'var(--muted)';
      }

      async function loadFullCaption(options = {}) {
        const { card, captionElement, captionEditor, editButton } = options || {};
        if (!card || !captionEditor) {
          return false;
        }
        if (card.dataset?.captionLoaded === 'true') {
          return true;
        }
        const captionPath = card.dataset?.captionPath;
        if (!captionPath) {
          card.dataset.captionLoaded = 'true';
          return true;
        }

        const params = new URLSearchParams({ caption_path: captionPath });
        const originalLabel = editButton ? editButton.textContent : null;
        if (editButton) {
          editButton.disabled = true;
          editButton.textContent = 'Loading…';
        }

        try {
          const response = await fetch(`/dataset/caption?${params.toString()}`);
          if (!response.ok) {
            throw new Error('Failed to load caption text.');
          }
          const data = await response.json();
          const captionText = data?.caption_text ?? '';
          const captionPathResponse = data?.caption_path || '';
          captionEditor.value = captionText;
          captionEditor.rows = Math.min(8, Math.max(3, captionText.split(/\n/).length || 3));
          if (captionElement) {
            if (captionText) {
              captionElement.textContent = captionText;
              captionElement.classList.remove('dataset-card-caption--empty');
            } else {
              captionElement.textContent = NO_CAPTION_TEXT;
              captionElement.classList.add('dataset-card-caption--empty');
            }
          }
          if (captionPathResponse) {
            card.dataset.captionPath = captionPathResponse;
          } else {
            delete card.dataset.captionPath;
          }
          card.dataset.captionLoaded = 'true';
          return true;
        } catch (error) {
          setDatasetMessage(error?.message || 'Failed to load caption text.', true);
          throw error;
        } finally {
          if (editButton) {
            editButton.disabled = false;
            editButton.textContent = originalLabel ?? 'Edit';
          }
        }
      }

      function startCaptionEditing(card, editButton, captionEditor) {
        if (!card || !editButton || !captionEditor) {
          return;
        }
        card.classList.add('dataset-card--editing');
        editButton.textContent = 'Save';
        captionEditor.focus();
        const length = captionEditor.value.length;
        captionEditor.setSelectionRange(length, length);
      }

      async function saveCaptionEdit(options) {
        const { card, editButton, captionElement, captionEditor } = options || {};
        if (!card || !editButton || !captionElement || !captionEditor) {
          return;
        }
        const mediaPath = card.dataset?.mediaPath;
        if (!mediaPath) {
          return;
        }
        const payload = {
          media_path: mediaPath,
          caption_text: captionEditor.value,
        };
        const captionPath = card.dataset?.captionPath;
        if (captionPath) {
          payload.caption_path = captionPath;
        }
        editButton.disabled = true;
        editButton.textContent = 'Saving…';
        try {
          const response = await fetch('/dataset/caption', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          let result = {};
          try {
            result = await response.json();
          } catch (error) {
            result = {};
          }
          if (!response.ok) {
            const detail = result?.detail || result?.message || 'Failed to update caption.';
            throw new Error(detail);
          }
          const newCaption = result?.caption_text ?? '';
          const newCaptionPath = result?.caption_path ?? '';
          if (newCaptionPath) {
            card.dataset.captionPath = newCaptionPath;
          } else {
            delete card.dataset.captionPath;
          }
          const body = card.querySelector('.dataset-card-body');
          let captionMeta = card.querySelector('.dataset-card-meta');
          if (newCaptionPath) {
            if (!captionMeta && body) {
              captionMeta = document.createElement('p');
              captionMeta.className = 'dataset-card-meta';
              const captionWrapper = body.querySelector('.dataset-card-caption-wrapper');
              if (captionWrapper) {
                body.insertBefore(captionMeta, captionWrapper);
              } else {
                body.appendChild(captionMeta);
              }
            }
            if (captionMeta) {
              captionMeta.textContent = `Caption: ${newCaptionPath}`;
            }
          } else if (captionMeta) {
            captionMeta.remove();
          }
          captionEditor.value = newCaption;
          if (newCaption) {
            captionElement.textContent = newCaption;
            captionElement.classList.remove('dataset-card-caption--empty');
          } else {
            captionElement.textContent = NO_CAPTION_TEXT;
            captionElement.classList.add('dataset-card-caption--empty');
          }
          card.dataset.captionLoaded = 'true';
          card.classList.remove('dataset-card--editing');
          setDatasetMessage(result?.message || 'Caption updated.');
        } catch (error) {
          setDatasetMessage(error?.message || 'Failed to update caption.', true);
        } finally {
          editButton.disabled = false;
          editButton.textContent = card.classList.contains('dataset-card--editing') ? 'Save' : 'Edit';
        }
      }

      async function handleDatasetItemRemoval(mediaPath, card, button) {
        if (!mediaPath) {
          return;
        }
        const segments = mediaPath.split('/');
        const displayName = segments[segments.length - 1] || mediaPath;
        const confirmed = window.confirm(
          `Remove “${displayName}” from the dataset? This will delete the media file and its captions.`
        );
        if (!confirmed) {
          return;
        }
        if (button) {
          button.disabled = true;
        }
        if (card) {
          card.classList.add('dataset-card--removing');
        }
        try {
          const response = await fetch('/dataset/delete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ media_path: mediaPath }),
          });
          let result = {};
          try {
            result = await response.json();
          } catch (error) {
            result = {};
          }
          if (!response.ok) {
            const detail = result?.detail || result?.message || 'Failed to remove media from dataset.';
            throw new Error(detail);
          }
          const message = result?.message || `Removed “${displayName}” from the dataset.`;
          await refreshDatasetPreview({ message });
        } catch (error) {
          setDatasetMessage(error?.message || 'Failed to remove media from dataset.', true);
        } finally {
          if (button) {
            button.disabled = false;
          }
          if (card) {
            card.classList.remove('dataset-card--removing');
          }
        }
      }

      function createDatasetCard(item) {
        const card = document.createElement('article');
        card.className = 'dataset-card';
        card.setAttribute('role', 'listitem');

        const mediaPath = item?.media_path || item?.image_path || item?.video_path || '';
        card.dataset.mediaPath = mediaPath;
        if (item?.caption_path) {
          card.dataset.captionPath = item.caption_path;
        }

        let captionElement;
        let captionEditor;

        const mediaUrl = item?.media_url || item?.image_url || item?.video_url || '';
        const isVideo =
          item?.media_kind === 'video' ||
          (typeof mediaPath === 'string' && VIDEO_EXTENSION_PATTERN.test(mediaPath));

        const cacheKey = mediaPath || mediaUrl;

        let mediaElement;
        if (isVideo) {
          mediaElement = document.createElement('video');
          mediaElement.preload = 'metadata';
          mediaElement.muted = true;
          mediaElement.defaultMuted = true;
          mediaElement.loop = true;
          mediaElement.playsInline = true;
          mediaElement.setAttribute('playsinline', '');
          mediaElement.setAttribute('webkit-playsinline', '');
          mediaElement.setAttribute('muted', '');
          mediaElement.controls = true;
          mediaElement.setAttribute('controlslist', 'nodownload noremoteplayback');
          mediaElement.draggable = false;
          if (mediaUrl) {
            const cacheBuster = encodeURIComponent(cacheKey);
            mediaElement.src = `${mediaUrl}?v=${cacheBuster}`;
          }
          mediaElement.setAttribute(
            'aria-label',
            mediaPath ? `Dataset video ${mediaPath}` : 'Dataset video preview'
          );
        } else {
          mediaElement = document.createElement('img');
          mediaElement.loading = 'lazy';
          mediaElement.decoding = 'async';
          mediaElement.draggable = false;
          if (mediaUrl) {
            const cacheBuster = encodeURIComponent(cacheKey);
            mediaElement.src = `${mediaUrl}?v=${cacheBuster}`;
          }
          mediaElement.alt = mediaPath
            ? `Dataset image ${mediaPath}`
            : 'Dataset image preview';
        }
        mediaElement.className = 'dataset-card-media';
        if (mediaPath) {
          mediaElement.title = mediaPath;
        }
        card.appendChild(mediaElement);

        if (mediaPath) {
          const actions = document.createElement('div');
          actions.className = 'dataset-card-actions';

          const editButton = document.createElement('button');
          editButton.type = 'button';
          editButton.className = 'dataset-card-edit';
          editButton.textContent = 'Edit';
          editButton.addEventListener('click', async (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (!captionElement || !captionEditor) {
              return;
            }
            if (card.classList.contains('dataset-card--editing')) {
              await saveCaptionEdit({ card, editButton, captionElement, captionEditor });
            } else {
              try {
                await loadFullCaption({ card, captionElement, captionEditor, editButton });
              } catch (error) {
                return;
              }
              startCaptionEditing(card, editButton, captionEditor);
            }
          });
          actions.appendChild(editButton);

          const removeButton = document.createElement('button');
          removeButton.type = 'button';
          removeButton.className = 'dataset-card-remove';
          removeButton.textContent = 'Remove';
          removeButton.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            handleDatasetItemRemoval(mediaPath, card, removeButton);
          });
          actions.appendChild(removeButton);

          card.appendChild(actions);
        }

        const body = document.createElement('div');
        body.className = 'dataset-card-body';

        const title = document.createElement('p');
        title.className = 'dataset-card-title';
        title.textContent = mediaPath || 'Unknown file';
        body.appendChild(title);

        if (item?.caption_path) {
          const captionMeta = document.createElement('p');
          captionMeta.className = 'dataset-card-meta';
          captionMeta.textContent = `Caption: ${item.caption_path}`;
          body.appendChild(captionMeta);
        }

        const captionWrapper = document.createElement('div');
        captionWrapper.className = 'dataset-card-caption-wrapper';

        captionElement = document.createElement('p');
        captionElement.className = 'dataset-card-caption';
        if (item?.caption_text) {
          captionElement.textContent = item.caption_text;
        } else {
          captionElement.textContent = NO_CAPTION_TEXT;
          captionElement.classList.add('dataset-card-caption--empty');
        }

        captionEditor = document.createElement('textarea');
        captionEditor.className = 'dataset-card-caption-editor';
        captionEditor.value = item?.caption_text || '';
        captionEditor.rows = Math.min(8, Math.max(3, captionEditor.value.split(/\n/).length || 3));
        captionEditor.placeholder = 'Enter caption text…';
        captionEditor.spellcheck = false;
        captionEditor.setAttribute('aria-label', `Edit caption for ${mediaPath || 'this media item'}`);

        captionWrapper.appendChild(captionElement);
        captionWrapper.appendChild(captionEditor);
        body.appendChild(captionWrapper);

        card.appendChild(body);
        return card;
      }

      function renderDatasetPreview(items) {
        if (!datasetGrid) {
          return;
        }
        datasetGrid.innerHTML = '';
        if (!items?.length) {
          return;
        }
        const fragment = document.createDocumentFragment();
        items.forEach((item) => {
          fragment.appendChild(createDatasetCard(item));
        });
        datasetGrid.appendChild(fragment);
      }

      async function refreshDatasetPreview(options = {}) {
        const { message: overrideMessage = null, isError = false } = options || {};
        if (!datasetGrid || !datasetMessage) {
          return;
        }
        setDatasetMessage('Loading dataset preview…');
        datasetGrid.setAttribute('aria-busy', 'true');
        datasetGrid.innerHTML = '';
        try {
          const response = await fetch('/dataset/files');
          if (!response.ok) {
            throw new Error('Failed to fetch dataset preview');
          }
          const data = await response.json();
          const items = Array.isArray(data?.items) ? data.items : [];
          if (!items.length) {
            const emptyMessage = overrideMessage ?? 'No dataset files uploaded yet.';
            setDatasetMessage(emptyMessage, overrideMessage != null ? isError : false);
            return;
          }
          renderDatasetPreview(items);
          const totalValue = Number(data?.total);
          const total = Number.isFinite(totalValue) && totalValue >= 0 ? totalValue : items.length;
          if (overrideMessage != null) {
            setDatasetMessage(overrideMessage, isError);
          } else {
            setDatasetMessage(`Showing ${total} media file${total === 1 ? '' : 's'} from the current dataset.`);
          }
        } catch (error) {
          setDatasetMessage(error?.message || 'Failed to load dataset preview.', true);
        } finally {
          datasetGrid.removeAttribute('aria-busy');
        }
      }

      function setApiKeyMessage(text = '', isError = false) {
        if (!apiKeyMessageEl) {
          return;
        }
        apiKeyMessageEl.textContent = text;
        apiKeyMessageEl.style.color = isError ? '#ff8a80' : 'var(--muted)';
      }

      function setCloudStatusUI(status) {
        currentCloudStatus = status || null;
        if (cloudStatusMessageEl) {
          const message = status?.message || '';
          cloudStatusMessageEl.textContent = message;
          if (!status) {
            cloudStatusMessageEl.style.color = 'var(--muted)';
          } else if (status.permission_error) {
            cloudStatusMessageEl.style.color = '#ff8a80';
          } else if (status.can_upload) {
            cloudStatusMessageEl.style.color = 'var(--accent)';
          } else {
            cloudStatusMessageEl.style.color = 'var(--muted)';
          }
        }

        if (!uploadCloudCheckbox) {
          return;
        }

        const disableCheckbox = !status || status.permission_error || !status.cli_available;
        uploadCloudCheckbox.disabled = disableCheckbox;
        if (disableCheckbox) {
          uploadCloudCheckbox.checked = false;
        } else if (status && !status.has_connections) {
          uploadCloudCheckbox.checked = false;
        }

        if (uploadCloudLabel) {
          uploadCloudLabel.classList.toggle('disabled', disableCheckbox);
        }
      }

      async function refreshCloudStatus() {
        try {
          const response = await fetch('/cloud-status');
          if (!response.ok) {
            throw new Error('Failed to fetch cloud status');
          }
          const data = await response.json();
          setCloudStatusUI(data);
        } catch (error) {
          if (cloudStatusMessageEl) {
            cloudStatusMessageEl.textContent = 'Unable to determine cloud connection status.';
            cloudStatusMessageEl.style.color = '#ff8a80';
          }
          currentCloudStatus = null;
        }
      }

      async function saveApiKey() {
        if (!apiKeyInput) {
          return;
        }
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) {
          setApiKeyMessage('Enter an API key from https://cloud.vast.ai/manage-keys.', true);
          return;
        }

        if (apiKeyButton) {
          apiKeyButton.disabled = true;
        }
        setApiKeyMessage('Saving API key…');

        try {
          const response = await fetch('/vast-api-key', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ api_key: apiKey }),
          });
          const data = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(data.detail || 'Failed to save API key');
          }
          apiKeyInput.value = '';
          setApiKeyMessage(data.message || 'API key saved.');
          if (data.cloud_status) {
            setCloudStatusUI(data.cloud_status);
          } else {
            await refreshCloudStatus();
          }
        } catch (error) {
          setApiKeyMessage(error.message || 'Failed to save API key.', true);
        } finally {
          if (apiKeyButton) {
            apiKeyButton.disabled = false;
          }
        }
      }

      if (apiKeyButton) {
        apiKeyButton.addEventListener('click', saveApiKey);
      }

      if (apiKeyInput) {
        apiKeyInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            saveApiKey();
          }
        });
      }

      const runDisplays = {
        high: {
          step: highStepEl,
          loss: highLossEl,
          epoch: highEpochEl,
          total: highTotalStepsEl,
          elapsed: highElapsedEl,
          eta: highEtaEl,
          status: highStatusEl,
          card: highCardEl,
        },
        low: {
          step: lowStepEl,
          loss: lowLossEl,
          epoch: lowEpochEl,
          total: lowTotalStepsEl,
          elapsed: lowElapsedEl,
          eta: lowEtaEl,
          status: lowStatusEl,
          card: lowCardEl,
        },
      };
      const noiseModeInputs = form.querySelectorAll('input[name="noiseMode"]');

      let chart;
      let activeRuns = new Set(['high', 'low']);

      function setRunState(run, isActive, message = '') {
        const display = runDisplays[run];
        if (!display) {
          return;
        }
        if (display.card) {
          if (isActive) {
            display.card.classList.remove('metric-card--disabled');
            display.card.removeAttribute('aria-disabled');
          } else {
            display.card.classList.add('metric-card--disabled');
            display.card.setAttribute('aria-disabled', 'true');
          }
        }
        if (display.status) {
          display.status.textContent = message || '';
          display.status.style.display = message ? 'block' : 'none';
        }
      }

      function updateActiveRuns(runs) {
        const normalized = Array.isArray(runs)
          ? runs
              .map((run) => {
                if (run === 'high' || run === 'low') {
                  return run;
                }
                return null;
              })
              .filter(Boolean)
          : [];
        if (!normalized.length) {
          normalized.push('high', 'low');
        }
        activeRuns = new Set(normalized);
        ['high', 'low'].forEach((run) => {
          const isActive = activeRuns.has(run);
          const statusText = isActive ? '' : 'Disabled in configuration.';
          setRunState(run, isActive, statusText);
        });
        if (chart && chart.data && Array.isArray(chart.data.datasets)) {
          const datasets = chart.data.datasets;
          if (datasets[0]) {
            datasets[0].hidden = !activeRuns.has('high');
          }
          if (datasets[1]) {
            datasets[1].hidden = !activeRuns.has('low');
          }
          chart.update('none');
        }
      }

      noiseModeInputs.forEach((input) => {
        input.addEventListener('change', () => {
          if (startButton.disabled) {
            return;
          }
          const value = (input.value || '').toLowerCase();
          const runs = value === 'high' ? ['high'] : value === 'low' ? ['low'] : ['high', 'low'];
          updateActiveRuns(runs);
        });
      });

      refreshCloudStatus();

      function updateRunDisplay(run, current) {
        const display = runDisplays[run];
        if (!display) {
          return;
        }
        const hasData = current && typeof current === 'object';
        const stepValue = hasData && current.step != null ? current.step : '-';
        const lossValue = hasData && current.loss != null && Number.isFinite(Number(current.loss))
          ? Number(current.loss).toFixed(6)
          : '-';
        const totalValue = hasData && current.total_steps != null ? current.total_steps : '-';
        const epochValue = hasData && current.epoch != null ? current.epoch : '-';
        const totalEpochValue = hasData && current.total_epochs != null ? current.total_epochs : '-';
        let epochDisplay = '-';
        if (epochValue !== '-') {
          epochDisplay = totalEpochValue !== '-' ? `${epochValue} / ${totalEpochValue}` : `${epochValue}`;
        }
        const elapsedValue = hasData && current.time_elapsed ? current.time_elapsed : '-';
        const remainingValue = hasData && current.time_remaining ? current.time_remaining : '-';
        display.step.textContent = stepValue;
        display.loss.textContent = lossValue;
        display.epoch.textContent = epochDisplay;
        display.total.textContent = totalValue;
        display.elapsed.textContent = elapsedValue;
        display.eta.textContent = remainingValue;
      }

      function initChart() {
        const ctx = document.getElementById('lossChart').getContext('2d');
        chart = new Chart(ctx, {
          type: 'line',
          data: {
            datasets: [
              {
                label: 'High noise loss',
                data: [],
                borderColor: 'rgba(138, 180, 248, 0.95)',
                backgroundColor: 'rgba(138, 180, 248, 0.15)',
                tension: 0.2,
                pointRadius: 0,
                borderWidth: 2,
              },
              {
                label: 'Low noise loss',
                data: [],
                borderColor: 'rgba(166, 107, 255, 0.95)',
                backgroundColor: 'rgba(166, 107, 255, 0.15)',
                tension: 0.2,
                pointRadius: 0,
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            animation: false,
            maintainAspectRatio: false,
            interaction: {
              mode: 'index',
              intersect: false,
              axis: 'x',
            },
            scales: {
              x: {
                type: 'linear',
                title: { display: true, text: 'Step' },
                ticks: { color: '#bdc1c6' },
                grid: { color: 'rgba(189, 193, 198, 0.1)' },
              },
              y: {
                title: { display: true, text: 'Loss' },
                ticks: { color: '#bdc1c6' },
                grid: { color: 'rgba(189, 193, 198, 0.1)' },
              },
            },
            plugins: {
              legend: {
                labels: {
                  color: '#e8eaed',
                },
              },
              tooltip: {
                intersect: false,
                callbacks: {
                  title: (context) => {
                    if (!context?.length) {
                      return '';
                    }
                    const step = context[0].parsed?.x;
                    return Number.isFinite(step) ? `Step ${step}` : '';
                  },
                  label: (context) => {
                    const label = context.dataset?.label || '';
                    const loss = context.parsed?.y;
                    if (!Number.isFinite(loss)) {
                      return label;
                    }
                    return `${label}: ${loss.toFixed(6)}`;
                  },
                },
              },
            },
          },
        });
      }

      initChart();
      updateActiveRuns([...activeRuns]);

      refreshDatasetPreview();

      function resetChart() {
        chart.data.datasets.forEach((dataset) => {
          dataset.data = [];
        });
        chart.update('none');
        updateRunDisplay('high', null);
        updateRunDisplay('low', null);
        ['high', 'low'].forEach((run) => {
          const isActive = activeRuns.has(run);
          setRunState(run, isActive, isActive ? '' : 'Disabled in configuration.');
        });
        logLines.length = 0;
        logOutput.textContent = 'Waiting for training output…';
        stopButton.disabled = true;
      }

      async function uploadFiles(fileList) {
        if (!fileList || !fileList.length) {
          return;
        }
        const formData = new FormData();
        Array.from(fileList).forEach((file) => formData.append('files', file, file.name));
        uploadSummary.textContent = 'Uploading ' + fileList.length + ' file(s)…';
        try {
          const response = await fetch('/upload', {
            method: 'POST',
            body: formData,
          });
          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.detail || 'Upload failed');
          }
          const result = await response.json();
          uploadSummary.textContent = `Uploaded ${result.count} file(s).`;
        } catch (error) {
          uploadSummary.textContent = error.message || 'Upload failed';
        } finally {
          await refreshDatasetPreview();
        }
      }

      dropzone.addEventListener('click', () => fileInput.click());
      dropzone.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          fileInput.click();
        }
      });

      ['dragenter', 'dragover'].forEach((type) => {
        dropzone.addEventListener(type, (event) => {
          event.preventDefault();
          event.dataTransfer.dropEffect = 'copy';
          dropzone.classList.add('active');
        });
      });

      dropzone.addEventListener('dragleave', (event) => {
        if (!dropzone.contains(event.relatedTarget)) {
          dropzone.classList.remove('active');
        }
      });

      document.addEventListener('dragover', (event) => {
        event.preventDefault();
      });

      document.addEventListener('drop', (event) => {
        if (!dropzone.contains(event.target)) {
          event.preventDefault();
        }
      });

      dropzone.addEventListener('mouseleave', () => {
        dropzone.classList.remove('active');
      });

      dropzone.addEventListener('drop', (event) => {
        event.preventDefault();
        dropzone.classList.remove('active');
        if (event.dataTransfer?.files?.length) {
          uploadFiles(event.dataTransfer.files);
        }
      });

      fileInput.addEventListener('change', (event) => {
        if (event.target.files?.length) {
          uploadFiles(event.target.files);
          fileInput.value = '';
        }
      });

      function setStatus(text) {
        statusEl.textContent = text;
      }

      function setMessage(text, isError = false) {
        messageEl.textContent = text;
        messageEl.style.color = isError ? '#ff8a80' : 'var(--muted)';
      }

      function updateLog(line) {
        if (!line) {
          return;
        }
        logLines.push(line);
        if (logLines.length > MAX_LOG_LINES) {
          logLines.splice(0, logLines.length - MAX_LOG_LINES);
        }
        logOutput.textContent = logLines.join('\n');
        logOutput.scrollTop = logOutput.scrollHeight;
      }

      function applyHistory(datasetIndex, history) {
        const dataset = chart.data.datasets[datasetIndex];
        dataset.data = history
          .map((point) => ({ x: Number(point.step), y: Number(point.loss) }))
          .filter((point) => Number.isFinite(point.x) && Number.isFinite(point.y));
      }

      function updateMetric(run, payload) {
        const datasetIndex = run === 'high' ? 0 : 1;
        const dataset = chart.data.datasets[datasetIndex];
        if (!payload) {
          return;
        }
        let datasetUpdated = false;
        const stepValue = Number(payload.step);
        const lossValue = Number(payload.loss);
        if (Number.isFinite(stepValue) && Number.isFinite(lossValue)) {
          if (dataset.data.length && dataset.data[dataset.data.length - 1].x === stepValue) {
            dataset.data[dataset.data.length - 1].y = lossValue;
          } else {
            dataset.data.push({ x: stepValue, y: lossValue });
          }
          datasetUpdated = true;
        }
        const currentData = payload.current ? { ...payload.current } : {};
        if (!('step' in currentData) && Number.isFinite(stepValue)) {
          currentData.step = stepValue;
        }
        if (!('loss' in currentData) && Number.isFinite(lossValue)) {
          currentData.loss = lossValue;
        }
        updateRunDisplay(run, Object.keys(currentData).length ? currentData : null);
        if (datasetUpdated) {
          chart.update('none');
        }
      }

      function applySnapshot(snapshot) {
        setStatus(snapshot.status ? snapshot.status.charAt(0).toUpperCase() + snapshot.status.slice(1) : 'Idle');
        startButton.disabled = !!snapshot.running;
        stopButton.disabled = !snapshot.running;
        if (snapshot.noise_mode) {
          const noiseInput = form.querySelector(`input[name="noiseMode"][value="${snapshot.noise_mode}"]`);
          if (noiseInput) {
            noiseInput.checked = true;
          }
        }
        updateActiveRuns(Array.isArray(snapshot.active_runs) ? snapshot.active_runs : ['high', 'low']);
        applyHistory(0, snapshot.high?.history || []);
        applyHistory(1, snapshot.low?.history || []);
        updateRunDisplay('high', snapshot.high?.current || null);
        updateRunDisplay('low', snapshot.low?.current || null);
        chart.update('none');
        logLines.length = 0;
        (snapshot.logs || []).forEach((line) => logLines.push(line));
        if (logLines.length) {
          logOutput.textContent = logLines.join('\n');
          logOutput.scrollTop = logOutput.scrollHeight;
        } else {
          logOutput.textContent = 'Waiting for training output…';
        }
      }

      async function startTraining(event) {
        event.preventDefault();
        const formData = new FormData(form);
        const trainingModeRaw = (formData.get('trainingMode') || 't2v').toString().toLowerCase();
        const trainingMode = trainingModeRaw === 'i2v' ? 'i2v' : 't2v';
        const noiseModeRaw = (formData.get('noiseMode') || 'both').toString().toLowerCase();
        const noiseMode = noiseModeRaw === 'high' || noiseModeRaw === 'low' ? noiseModeRaw : 'both';
        const selectedRuns = noiseMode === 'high' ? ['high'] : noiseMode === 'low' ? ['low'] : ['high', 'low'];
        const payload = {
          title_suffix: (formData.get('titleSuffix') || '').toString().trim() || 'mylora',
          author: (formData.get('author') || '').toString().trim() || 'authorName',
          dataset_path: (formData.get('datasetPath') || '').toString().trim(),
          save_every: Number(formData.get('saveEvery')) || 100,
          cpu_threads_per_process: formData.get('cpuThreads') ? Number(formData.get('cpuThreads')) : null,
          max_data_loader_workers: formData.get('maxWorkers') ? Number(formData.get('maxWorkers')) : null,
          upload_cloud: formData.get('uploadCloud') === 'on',
          shutdown_instance: formData.get('shutdownInstance') === 'on',
          convert_videos_to_16fps: formData.get('convertVideos') === 'on',
          auto_confirm: true,
          training_mode: trainingMode,
          noise_mode: noiseMode,
        };

        if (currentCloudStatus && !currentCloudStatus.can_upload) {
          payload.upload_cloud = false;
        }

        if (!payload.dataset_path) {
          setMessage('Dataset config path is required.', true);
          return;
        }

        resetChart();
        setMessage('Launching training…');
        startButton.disabled = true;

        try {
          const response = await fetch('/train', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.detail || 'Failed to start training');
          }
          updateActiveRuns(selectedRuns);
          setMessage('Training started. Watching logs…');
          stopButton.disabled = false;
        } catch (error) {
          startButton.disabled = false;
          setMessage(error.message || 'Failed to start training', true);
        }
      }

      form.addEventListener('submit', startTraining);

      async function stopTraining() {
        stopButton.disabled = true;
        setMessage('Stopping training…');
        try {
          const response = await fetch('/stop', { method: 'POST' });
          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.detail || 'Failed to stop training');
          }
          setMessage('Stop requested. Waiting for training to halt…');
        } catch (error) {
          setMessage(error.message || 'Failed to stop training', true);
          stopButton.disabled = false;
        }
      }

      stopButton.addEventListener('click', stopTraining);

      function handleEvent(event) {
        const data = event.data ? JSON.parse(event.data) : null;
        if (!data) return;
        switch (data.type) {
          case 'snapshot':
            applySnapshot(data);
            break;
          case 'status':
            setStatus(data.status ? data.status.charAt(0).toUpperCase() + data.status.slice(1) : 'Idle');
            startButton.disabled = !!data.running;
            stopButton.disabled = !data.running;
            if (data.status === 'failed') {
              setMessage('Training failed. See logs for details.', true);
            } else if (data.status === 'completed') {
              setMessage('Training completed successfully.');
            } else if (data.status === 'stopping') {
              setMessage('Stop requested. Waiting for training to halt…');
            } else if (data.status === 'stopped') {
              setMessage('Training stopped by user.');
            }
            break;
          case 'metrics':
            updateMetric(data.run, data);
            break;
          case 'log':
            updateLog(data.line);
            break;
          default:
            break;
        }
      }

      const eventSource = new EventSource('/events');
      eventSource.onmessage = handleEvent;
      eventSource.onerror = () => {
        setMessage('Lost connection to live updates. Retrying…', true);
      };
    </script>
  </body>
</html>
