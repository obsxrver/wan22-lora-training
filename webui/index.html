<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WAN 2.2 LoRA Training</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #121212;
        --panel: #1f1f1f;
        --accent: #8ab4f8;
        --accent-strong: #a66bff;
        --border: #2a2a2a;
        --text: #f1f3f4;
        --muted: #9aa0a6;
      }

      body {
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        margin: 0;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
      }

      header {
        padding: 2rem 1.5rem 1rem;
        text-align: center;
        background: linear-gradient(135deg, rgba(138, 180, 248, 0.25), rgba(166, 107, 255, 0.25));
        border-bottom: 1px solid var(--border);
      }

      header h1 {
        margin: 0 0 0.5rem;
        font-size: 2rem;
      }

      header p {
        margin: 0;
        color: var(--muted);
      }

      .nav-links {
        margin-top: 1rem;
        display: flex;
        justify-content: center;
      }

      .nav-button {
        display: inline-block;
        padding: 0.6rem 1.4rem;
        border-radius: 999px;
        background: var(--accent);
        color: var(--bg);
        font-weight: 600;
        text-decoration: none;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .nav-button:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(138, 180, 248, 0.35);
      }

      main {
        max-width: 1100px;
        margin: 0 auto;
        padding: 1.5rem;
        display: grid;
        gap: 1.5rem;
      }

      section {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      }

      h2 {
        margin-top: 0;
        font-size: 1.35rem;
      }

      #dropzone {
        border: 2px dashed var(--accent);
        border-radius: 16px;
        padding: 2rem;
        text-align: center;
        transition: background 0.2s ease, border-color 0.2s ease;
        cursor: pointer;
        color: var(--muted);
        font-size: 1rem;
        outline: none;
      }

      #dropzone.active {
        background: rgba(138, 180, 248, 0.12);
        border-color: var(--accent-strong);
        color: var(--text);
      }

      #dropzone:focus-visible {
        border-color: var(--accent-strong);
        box-shadow: 0 0 0 3px rgba(138, 180, 248, 0.25);
        color: var(--text);
      }

      #fileInput {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        border: 0;
        clip: rect(0, 0, 0, 0);
        overflow: hidden;
      }

      #upload-summary {
        margin-top: 1rem;
        font-size: 0.95rem;
        color: var(--muted);
      }

      #dataset-preview-section {
        margin-top: 1.5rem;
      }

      #dataset-preview-section h3 {
        margin: 0;
        font-size: 1.1rem;
      }

      #dataset-preview-message {
        margin-top: 0.75rem;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .dataset-grid {
        margin-top: 1rem;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 1rem;
      }

      .dataset-card {
        border: 1px solid var(--border);
        border-radius: 12px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.04);
        display: flex;
        flex-direction: column;
        min-height: 100%;
      }

      .dataset-card img {
        width: 100%;
        height: 180px;
        object-fit: cover;
        background: rgba(0, 0, 0, 0.35);
      }

      .dataset-card-body {
        padding: 0.9rem;
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
      }

      .dataset-card-title {
        margin: 0;
        font-weight: 600;
        font-size: 0.95rem;
        color: var(--text);
        word-break: break-word;
      }

      .dataset-card-meta {
        margin: 0;
        font-size: 0.75rem;
        color: var(--muted);
        word-break: break-word;
      }

      .dataset-card-caption {
        margin: 0;
        font-size: 0.85rem;
        color: var(--muted);
        white-space: pre-wrap;
      }

      .dataset-card-caption--empty {
        font-style: italic;
      }

      form {
        display: grid;
        gap: 1rem;
      }

      .form-row {
        display: grid;
        gap: 1rem;
      }

      .form-row.two-col {
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      label {
        display: flex;
        flex-direction: column;
        font-weight: 600;
        color: var(--muted);
        gap: 0.4rem;
      }

      a {
        color: var(--accent);
        text-decoration: none;
      }

      a:hover {
        color: var(--accent-strong);
      }

      input[type="text"],
      input[type="number"] {
        padding: 0.6rem 0.75rem;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        font-size: 0.95rem;
      }

      input[type="checkbox"] {
        width: 1.1rem;
        height: 1.1rem;
        accent-color: var(--accent);
      }

      .toggle {
        display: flex;
        align-items: center;
        gap: 0.6rem;
        font-weight: 600;
        color: var(--muted);
      }

      .toggle.disabled {
        opacity: 0.5;
        pointer-events: none;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 0.8rem 1.4rem;
        font-size: 1rem;
        font-weight: 600;
        background: linear-gradient(135deg, var(--accent), var(--accent-strong));
        color: var(--text);
        cursor: pointer;
        transition: transform 0.15s ease, opacity 0.15s ease;
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      button:not(:disabled):hover {
        transform: translateY(-1px);
      }

      .button-secondary {
        background: linear-gradient(135deg, #ff8a80, #ff5252);
      }

      #status-line {
        font-size: 1rem;
        font-weight: 600;
        color: var(--accent);
      }

      #message {
        color: var(--muted);
        font-size: 0.95rem;
        min-height: 1.2rem;
      }

      .metrics {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .metric-card {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 1rem;
        background: rgba(255, 255, 255, 0.03);
      }

      .status-note {
        font-size: 0.9rem;
        color: var(--muted);
      }

      #cloudStatusMessage,
      #apiKeyMessage {
        min-height: 1.2rem;
      }

      .api-key-row {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-top: 0.5rem;
      }

      .api-key-row input[type="text"] {
        flex: 1;
      }

      .button-inline {
        padding: 0.6rem 1rem;
        border-radius: 12px;
        white-space: nowrap;
      }

      .metric-card h3 {
        margin: 0 0 0.5rem;
        font-size: 1.1rem;
      }

      .metric-card p {
        margin: 0.2rem 0;
        font-size: 0.95rem;
        color: var(--muted);
      }

      canvas {
        width: 100% !important;
        max-height: 320px;
      }

      #logOutput {
        background: rgba(0, 0, 0, 0.35);
        border-radius: 12px;
        border: 1px solid var(--border);
        padding: 1rem;
        max-height: 280px;
        overflow-y: auto;
        font-family: "JetBrains Mono", "Fira Code", monospace;
        font-size: 0.85rem;
        line-height: 1.45;
        white-space: pre-wrap;
      }

      @media (max-width: 768px) {
        header {
          padding: 1.5rem 1rem 1rem;
        }
        main {
          padding: 1rem;
        }
        .dataset-grid {
          grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
        }
        .dataset-card img {
          height: 150px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>WAN 2.2 LoRA Training</h1>
      <p>Upload your dataset, configure prompts, and launch training with live feedback.</p>
      <div class="nav-links">
        <a class="nav-button" href="/SillyCaption">Open SillyCaption Dataset Manager</a>
      </div>
    </header>
    <main>
      <section>
        <h2>1. Upload dataset files</h2>
        <div id="dropzone" role="button" tabindex="0" aria-controls="upload-summary" aria-describedby="dropzone-instructions">
          <strong>Drop images, videos, and caption files here</strong>
          <div id="dropzone-instructions">or click to browse from your machine.</div>
        </div>
        <input id="fileInput" type="file" multiple />
        <div id="upload-summary">Files will be saved to /workspace/musubi-tuner/dataset/.</div>
        <div id="dataset-preview-section">
          <h3>Current dataset</h3>
          <div id="dataset-preview-message" aria-live="polite">No dataset files uploaded yet.</div>
          <div id="dataset-grid" class="dataset-grid" role="list"></div>
        </div>
      </section>

      <section>
        <h2>2. Configure training</h2>
        <div id="status-line">Status: <span id="status">Idle</span></div>
        <div id="message"></div>
        <form id="trainingForm">
          <div class="form-row two-col">
            <label>
              Title suffix
              <input type="text" name="titleSuffix" value="mylora" required />
            </label>
            <label>
              Author
              <input type="text" name="author" value="authorName" required />
            </label>
          </div>
          <div class="form-row">
            <label>
              Dataset config path
              <input type="text" name="datasetPath" value="/workspace/musubi-tuner/dataset/dataset.toml" required />
            </label>
          </div>
          <div class="form-row two-col">
            <label>
              Save every N epochs
              <input type="number" name="saveEvery" min="1" value="20" />
            </label>
            <label>
              CPU threads per process (leave blank for auto)
              <input type="number" name="cpuThreads" min="1" placeholder="Auto" />
            </label>
            <label>
              Max data loader workers (leave blank for auto)
              <input type="number" name="maxWorkers" min="1" placeholder="Auto" />
            </label>
          </div>
          <div class="form-row two-col">
            <label class="toggle">
              <input type="checkbox" name="uploadCloud" checked />
              Upload LoRAs to cloud storage after training
            </label>
            <label class="toggle">
              <input type="checkbox" name="shutdownInstance" checked />
              Shut down instance after training
            </label>
          </div>
          <div id="cloudStatusMessage" class="status-note" aria-live="polite"></div>
          <div class="form-row">
            <label>
              Vast.ai API key for cloud uploads
              <span class="status-note"
                >Need a key? <a href="https://cloud.vast.ai/manage-keys" target="_blank" rel="noopener">Create one on Vast.ai</a>.</span
              >
              <div class="api-key-row">
                <input type="text" id="vastApiKeyInput" placeholder="Enter Vast.ai API key" autocomplete="off" spellcheck="false" />
                <button type="button" id="saveApiKeyButton" class="button-inline">Save key</button>
              </div>
              <div id="apiKeyMessage" class="status-note" aria-live="polite"></div>
            </label>
          </div>
          <div class="form-row two-col">
            <button id="startButton" type="submit">Start training</button>
            <button id="stopButton" type="button" class="button-secondary" disabled>Stop training</button>
          </div>
        </form>
      </section>

      <section>
        <h2>3. Live progress</h2>
        <div class="metrics">
          <div class="metric-card">
            <h3>High noise</h3>
            <p>Current step: <span id="highStep">-</span></p>
            <p>Current loss: <span id="highLoss">-</span></p>
            <p>Epoch: <span id="highEpoch">-</span></p>
            <p>Total steps: <span id="highTotalSteps">-</span></p>
            <p>Time elapsed: <span id="highElapsed">-</span></p>
            <p>Time remaining: <span id="highEta">-</span></p>
          </div>
          <div class="metric-card">
            <h3>Low noise</h3>
            <p>Current step: <span id="lowStep">-</span></p>
            <p>Current loss: <span id="lowLoss">-</span></p>
            <p>Epoch: <span id="lowEpoch">-</span></p>
            <p>Total steps: <span id="lowTotalSteps">-</span></p>
            <p>Time elapsed: <span id="lowElapsed">-</span></p>
            <p>Time remaining: <span id="lowEta">-</span></p>
          </div>
        </div>
        <canvas id="lossChart"></canvas>
      </section>

      <section>
        <h2>Training log</h2>
        <pre id="logOutput">Waiting for training output…</pre>
      </section>
    </main>

    <script
      src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"
      integrity="sha384-9nhczxUqK87bcKHh20fSQcTGD4qq5GhayNYSYWqwBkINBhOfQLg/P5HG5lF1urn4"
      crossorigin="anonymous"
    ></script>
    <script>
      const dropzone = document.getElementById('dropzone');
      const fileInput = document.getElementById('fileInput');
      const uploadSummary = document.getElementById('upload-summary');
      const datasetGrid = document.getElementById('dataset-grid');
      const datasetMessage = document.getElementById('dataset-preview-message');
      const form = document.getElementById('trainingForm');
      const statusEl = document.getElementById('status');
      const messageEl = document.getElementById('message');
      const startButton = document.getElementById('startButton');
      const highStepEl = document.getElementById('highStep');
      const highLossEl = document.getElementById('highLoss');
      const highEpochEl = document.getElementById('highEpoch');
      const highTotalStepsEl = document.getElementById('highTotalSteps');
      const highElapsedEl = document.getElementById('highElapsed');
      const highEtaEl = document.getElementById('highEta');
      const lowStepEl = document.getElementById('lowStep');
      const lowLossEl = document.getElementById('lowLoss');
      const lowEpochEl = document.getElementById('lowEpoch');
      const lowTotalStepsEl = document.getElementById('lowTotalSteps');
      const lowElapsedEl = document.getElementById('lowElapsed');
      const lowEtaEl = document.getElementById('lowEta');
      const stopButton = document.getElementById('stopButton');
      const logOutput = document.getElementById('logOutput');
      const uploadCloudCheckbox = form.querySelector('input[name="uploadCloud"]');
      const uploadCloudLabel = uploadCloudCheckbox ? uploadCloudCheckbox.closest('.toggle') : null;
      const cloudStatusMessageEl = document.getElementById('cloudStatusMessage');
      const apiKeyInput = document.getElementById('vastApiKeyInput');
      const apiKeyButton = document.getElementById('saveApiKeyButton');
      const apiKeyMessageEl = document.getElementById('apiKeyMessage');
      let currentCloudStatus = null;

      const MAX_LOG_LINES = 400;
      const logLines = [];

      function setDatasetMessage(text = '', isError = false) {
        if (!datasetMessage) {
          return;
        }
        datasetMessage.textContent = text;
        datasetMessage.style.display = text ? 'block' : 'none';
        datasetMessage.style.color = isError ? '#ff8a80' : 'var(--muted)';
      }

      function createDatasetCard(item) {
        const card = document.createElement('article');
        card.className = 'dataset-card';
        card.setAttribute('role', 'listitem');

        const image = document.createElement('img');
        image.loading = 'lazy';
        image.decoding = 'async';
        image.draggable = false;
        if (item?.image_url) {
          const cacheBuster = encodeURIComponent(item.image_path || item.image_url);
          image.src = `${item.image_url}?v=${cacheBuster}`;
        }
        image.alt = item?.image_path ? `Dataset image ${item.image_path}` : 'Dataset image preview';
        card.appendChild(image);

        const body = document.createElement('div');
        body.className = 'dataset-card-body';

        const title = document.createElement('p');
        title.className = 'dataset-card-title';
        title.textContent = item?.image_path || 'Unknown image';
        body.appendChild(title);

        if (item?.caption_path) {
          const captionMeta = document.createElement('p');
          captionMeta.className = 'dataset-card-meta';
          captionMeta.textContent = `Caption: ${item.caption_path}`;
          body.appendChild(captionMeta);
        }

        const caption = document.createElement('p');
        caption.className = 'dataset-card-caption';
        if (item?.caption_text) {
          caption.textContent = item.caption_text;
        } else {
          caption.textContent = 'No caption file found for this image.';
          caption.classList.add('dataset-card-caption--empty');
        }
        body.appendChild(caption);

        card.appendChild(body);
        return card;
      }

      function renderDatasetPreview(items) {
        if (!datasetGrid) {
          return;
        }
        datasetGrid.innerHTML = '';
        if (!items?.length) {
          return;
        }
        const fragment = document.createDocumentFragment();
        items.forEach((item) => {
          fragment.appendChild(createDatasetCard(item));
        });
        datasetGrid.appendChild(fragment);
      }

      async function refreshDatasetPreview() {
        if (!datasetGrid || !datasetMessage) {
          return;
        }
        setDatasetMessage('Loading dataset preview…');
        datasetGrid.setAttribute('aria-busy', 'true');
        datasetGrid.innerHTML = '';
        try {
          const response = await fetch('/dataset/files');
          if (!response.ok) {
            throw new Error('Failed to fetch dataset preview');
          }
          const data = await response.json();
          const items = Array.isArray(data?.items) ? data.items : [];
          if (!items.length) {
            setDatasetMessage('No dataset files uploaded yet.');
            return;
          }
          renderDatasetPreview(items);
          const totalValue = Number(data?.total);
          const total = Number.isFinite(totalValue) && totalValue >= 0 ? totalValue : items.length;
          setDatasetMessage(`Showing ${total} image${total === 1 ? '' : 's'} from the current dataset.`);
        } catch (error) {
          setDatasetMessage(error?.message || 'Failed to load dataset preview.', true);
        } finally {
          datasetGrid.removeAttribute('aria-busy');
        }
      }

      function setApiKeyMessage(text = '', isError = false) {
        if (!apiKeyMessageEl) {
          return;
        }
        apiKeyMessageEl.textContent = text;
        apiKeyMessageEl.style.color = isError ? '#ff8a80' : 'var(--muted)';
      }

      function setCloudStatusUI(status) {
        currentCloudStatus = status || null;
        if (cloudStatusMessageEl) {
          const message = status?.message || '';
          cloudStatusMessageEl.textContent = message;
          if (!status) {
            cloudStatusMessageEl.style.color = 'var(--muted)';
          } else if (status.permission_error) {
            cloudStatusMessageEl.style.color = '#ff8a80';
          } else if (status.can_upload) {
            cloudStatusMessageEl.style.color = 'var(--accent)';
          } else {
            cloudStatusMessageEl.style.color = 'var(--muted)';
          }
        }

        if (!uploadCloudCheckbox) {
          return;
        }

        const disableCheckbox = !status || status.permission_error || !status.cli_available;
        uploadCloudCheckbox.disabled = disableCheckbox;
        if (disableCheckbox) {
          uploadCloudCheckbox.checked = false;
        } else if (status && !status.has_connections) {
          uploadCloudCheckbox.checked = false;
        }

        if (uploadCloudLabel) {
          uploadCloudLabel.classList.toggle('disabled', disableCheckbox);
        }
      }

      async function refreshCloudStatus() {
        try {
          const response = await fetch('/cloud-status');
          if (!response.ok) {
            throw new Error('Failed to fetch cloud status');
          }
          const data = await response.json();
          setCloudStatusUI(data);
        } catch (error) {
          if (cloudStatusMessageEl) {
            cloudStatusMessageEl.textContent = 'Unable to determine cloud connection status.';
            cloudStatusMessageEl.style.color = '#ff8a80';
          }
          currentCloudStatus = null;
        }
      }

      async function saveApiKey() {
        if (!apiKeyInput) {
          return;
        }
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) {
          setApiKeyMessage('Enter an API key from https://cloud.vast.ai/manage-keys.', true);
          return;
        }

        if (apiKeyButton) {
          apiKeyButton.disabled = true;
        }
        setApiKeyMessage('Saving API key…');

        try {
          const response = await fetch('/vast-api-key', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ api_key: apiKey }),
          });
          const data = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(data.detail || 'Failed to save API key');
          }
          apiKeyInput.value = '';
          setApiKeyMessage(data.message || 'API key saved.');
          if (data.cloud_status) {
            setCloudStatusUI(data.cloud_status);
          } else {
            await refreshCloudStatus();
          }
        } catch (error) {
          setApiKeyMessage(error.message || 'Failed to save API key.', true);
        } finally {
          if (apiKeyButton) {
            apiKeyButton.disabled = false;
          }
        }
      }

      if (apiKeyButton) {
        apiKeyButton.addEventListener('click', saveApiKey);
      }

      if (apiKeyInput) {
        apiKeyInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            saveApiKey();
          }
        });
      }

      const runDisplays = {
        high: {
          step: highStepEl,
          loss: highLossEl,
          epoch: highEpochEl,
          total: highTotalStepsEl,
          elapsed: highElapsedEl,
          eta: highEtaEl,
        },
        low: {
          step: lowStepEl,
          loss: lowLossEl,
          epoch: lowEpochEl,
          total: lowTotalStepsEl,
          elapsed: lowElapsedEl,
          eta: lowEtaEl,
        },
      };

      refreshCloudStatus();

      function updateRunDisplay(run, current) {
        const display = runDisplays[run];
        if (!display) {
          return;
        }
        const hasData = current && typeof current === 'object';
        const stepValue = hasData && current.step != null ? current.step : '-';
        const lossValue = hasData && current.loss != null && Number.isFinite(Number(current.loss))
          ? Number(current.loss).toFixed(6)
          : '-';
        const totalValue = hasData && current.total_steps != null ? current.total_steps : '-';
        const epochValue = hasData && current.epoch != null ? current.epoch : '-';
        const totalEpochValue = hasData && current.total_epochs != null ? current.total_epochs : '-';
        let epochDisplay = '-';
        if (epochValue !== '-') {
          epochDisplay = totalEpochValue !== '-' ? `${epochValue} / ${totalEpochValue}` : `${epochValue}`;
        }
        const elapsedValue = hasData && current.time_elapsed ? current.time_elapsed : '-';
        const remainingValue = hasData && current.time_remaining ? current.time_remaining : '-';
        display.step.textContent = stepValue;
        display.loss.textContent = lossValue;
        display.epoch.textContent = epochDisplay;
        display.total.textContent = totalValue;
        display.elapsed.textContent = elapsedValue;
        display.eta.textContent = remainingValue;
      }

      let chart;
      function initChart() {
        const ctx = document.getElementById('lossChart').getContext('2d');
        chart = new Chart(ctx, {
          type: 'line',
          data: {
            datasets: [
              {
                label: 'High noise loss',
                data: [],
                borderColor: 'rgba(138, 180, 248, 0.95)',
                backgroundColor: 'rgba(138, 180, 248, 0.15)',
                tension: 0.2,
                pointRadius: 0,
                borderWidth: 2,
              },
              {
                label: 'Low noise loss',
                data: [],
                borderColor: 'rgba(166, 107, 255, 0.95)',
                backgroundColor: 'rgba(166, 107, 255, 0.15)',
                tension: 0.2,
                pointRadius: 0,
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            animation: false,
            maintainAspectRatio: false,
            interaction: {
              mode: 'index',
              intersect: false,
              axis: 'x',
            },
            scales: {
              x: {
                type: 'linear',
                title: { display: true, text: 'Step' },
                ticks: { color: '#bdc1c6' },
                grid: { color: 'rgba(189, 193, 198, 0.1)' },
              },
              y: {
                title: { display: true, text: 'Loss' },
                ticks: { color: '#bdc1c6' },
                grid: { color: 'rgba(189, 193, 198, 0.1)' },
              },
            },
            plugins: {
              legend: {
                labels: {
                  color: '#e8eaed',
                },
              },
              tooltip: {
                intersect: false,
                callbacks: {
                  title: (context) => {
                    if (!context?.length) {
                      return '';
                    }
                    const step = context[0].parsed?.x;
                    return Number.isFinite(step) ? `Step ${step}` : '';
                  },
                  label: (context) => {
                    const label = context.dataset?.label || '';
                    const loss = context.parsed?.y;
                    if (!Number.isFinite(loss)) {
                      return label;
                    }
                    return `${label}: ${loss.toFixed(6)}`;
                  },
                },
              },
            },
          },
        });
      }

      initChart();

      refreshDatasetPreview();

      function resetChart() {
        chart.data.datasets.forEach((dataset) => {
          dataset.data = [];
        });
        chart.update('none');
        updateRunDisplay('high', null);
        updateRunDisplay('low', null);
        logLines.length = 0;
        logOutput.textContent = 'Waiting for training output…';
        stopButton.disabled = true;
      }

      async function uploadFiles(fileList) {
        if (!fileList || !fileList.length) {
          return;
        }
        const formData = new FormData();
        Array.from(fileList).forEach((file) => formData.append('files', file, file.name));
        uploadSummary.textContent = 'Uploading ' + fileList.length + ' file(s)…';
        try {
          const response = await fetch('/upload', {
            method: 'POST',
            body: formData,
          });
          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.detail || 'Upload failed');
          }
          const result = await response.json();
          uploadSummary.textContent = `Uploaded ${result.count} file(s).`;
        } catch (error) {
          uploadSummary.textContent = error.message || 'Upload failed';
        } finally {
          await refreshDatasetPreview();
        }
      }

      dropzone.addEventListener('click', () => fileInput.click());
      dropzone.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          fileInput.click();
        }
      });

      ['dragenter', 'dragover'].forEach((type) => {
        dropzone.addEventListener(type, (event) => {
          event.preventDefault();
          event.dataTransfer.dropEffect = 'copy';
          dropzone.classList.add('active');
        });
      });

      dropzone.addEventListener('dragleave', (event) => {
        if (!dropzone.contains(event.relatedTarget)) {
          dropzone.classList.remove('active');
        }
      });

      document.addEventListener('dragover', (event) => {
        event.preventDefault();
      });

      document.addEventListener('drop', (event) => {
        if (!dropzone.contains(event.target)) {
          event.preventDefault();
        }
      });

      dropzone.addEventListener('mouseleave', () => {
        dropzone.classList.remove('active');
      });

      dropzone.addEventListener('drop', (event) => {
        event.preventDefault();
        dropzone.classList.remove('active');
        if (event.dataTransfer?.files?.length) {
          uploadFiles(event.dataTransfer.files);
        }
      });

      fileInput.addEventListener('change', (event) => {
        if (event.target.files?.length) {
          uploadFiles(event.target.files);
          fileInput.value = '';
        }
      });

      function setStatus(text) {
        statusEl.textContent = text;
      }

      function setMessage(text, isError = false) {
        messageEl.textContent = text;
        messageEl.style.color = isError ? '#ff8a80' : 'var(--muted)';
      }

      function updateLog(line) {
        if (!line) {
          return;
        }
        logLines.push(line);
        if (logLines.length > MAX_LOG_LINES) {
          logLines.splice(0, logLines.length - MAX_LOG_LINES);
        }
        logOutput.textContent = logLines.join('\n');
        logOutput.scrollTop = logOutput.scrollHeight;
      }

      function applyHistory(datasetIndex, history) {
        const dataset = chart.data.datasets[datasetIndex];
        dataset.data = history
          .map((point) => ({ x: Number(point.step), y: Number(point.loss) }))
          .filter((point) => Number.isFinite(point.x) && Number.isFinite(point.y));
      }

      function updateMetric(run, payload) {
        const datasetIndex = run === 'high' ? 0 : 1;
        const dataset = chart.data.datasets[datasetIndex];
        if (!payload) {
          return;
        }
        let datasetUpdated = false;
        const stepValue = Number(payload.step);
        const lossValue = Number(payload.loss);
        if (Number.isFinite(stepValue) && Number.isFinite(lossValue)) {
          if (dataset.data.length && dataset.data[dataset.data.length - 1].x === stepValue) {
            dataset.data[dataset.data.length - 1].y = lossValue;
          } else {
            dataset.data.push({ x: stepValue, y: lossValue });
          }
          datasetUpdated = true;
        }
        const currentData = payload.current ? { ...payload.current } : {};
        if (!('step' in currentData) && Number.isFinite(stepValue)) {
          currentData.step = stepValue;
        }
        if (!('loss' in currentData) && Number.isFinite(lossValue)) {
          currentData.loss = lossValue;
        }
        updateRunDisplay(run, Object.keys(currentData).length ? currentData : null);
        if (datasetUpdated) {
          chart.update('none');
        }
      }

      function applySnapshot(snapshot) {
        setStatus(snapshot.status ? snapshot.status.charAt(0).toUpperCase() + snapshot.status.slice(1) : 'Idle');
        startButton.disabled = !!snapshot.running;
        stopButton.disabled = !snapshot.running;
        applyHistory(0, snapshot.high?.history || []);
        applyHistory(1, snapshot.low?.history || []);
        updateRunDisplay('high', snapshot.high?.current || null);
        updateRunDisplay('low', snapshot.low?.current || null);
        chart.update('none');
        logLines.length = 0;
        (snapshot.logs || []).forEach((line) => logLines.push(line));
        if (logLines.length) {
          logOutput.textContent = logLines.join('\n');
          logOutput.scrollTop = logOutput.scrollHeight;
        } else {
          logOutput.textContent = 'Waiting for training output…';
        }
      }

      async function startTraining(event) {
        event.preventDefault();
        const formData = new FormData(form);
        const payload = {
          title_suffix: (formData.get('titleSuffix') || '').toString().trim() || 'mylora',
          author: (formData.get('author') || '').toString().trim() || 'authorName',
          dataset_path: (formData.get('datasetPath') || '').toString().trim(),
          save_every: Number(formData.get('saveEvery')) || 100,
          cpu_threads_per_process: formData.get('cpuThreads') ? Number(formData.get('cpuThreads')) : null,
          max_data_loader_workers: formData.get('maxWorkers') ? Number(formData.get('maxWorkers')) : null,
          upload_cloud: formData.get('uploadCloud') === 'on',
          shutdown_instance: formData.get('shutdownInstance') === 'on',
          auto_confirm: true,
        };

        if (currentCloudStatus && !currentCloudStatus.can_upload) {
          payload.upload_cloud = false;
        }

        if (!payload.dataset_path) {
          setMessage('Dataset config path is required.', true);
          return;
        }

        resetChart();
        setMessage('Launching training…');
        startButton.disabled = true;

        try {
          const response = await fetch('/train', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.detail || 'Failed to start training');
          }
          setMessage('Training started. Watching logs…');
          stopButton.disabled = false;
        } catch (error) {
          startButton.disabled = false;
          setMessage(error.message || 'Failed to start training', true);
        }
      }

      form.addEventListener('submit', startTraining);

      async function stopTraining() {
        stopButton.disabled = true;
        setMessage('Stopping training…');
        try {
          const response = await fetch('/stop', { method: 'POST' });
          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.detail || 'Failed to stop training');
          }
          setMessage('Stop requested. Waiting for training to halt…');
        } catch (error) {
          setMessage(error.message || 'Failed to stop training', true);
          stopButton.disabled = false;
        }
      }

      stopButton.addEventListener('click', stopTraining);

      function handleEvent(event) {
        const data = event.data ? JSON.parse(event.data) : null;
        if (!data) return;
        switch (data.type) {
          case 'snapshot':
            applySnapshot(data);
            break;
          case 'status':
            setStatus(data.status ? data.status.charAt(0).toUpperCase() + data.status.slice(1) : 'Idle');
            startButton.disabled = !!data.running;
            stopButton.disabled = !data.running;
            if (data.status === 'failed') {
              setMessage('Training failed. See logs for details.', true);
            } else if (data.status === 'completed') {
              setMessage('Training completed successfully.');
            } else if (data.status === 'stopping') {
              setMessage('Stop requested. Waiting for training to halt…');
            } else if (data.status === 'stopped') {
              setMessage('Training stopped by user.');
            }
            break;
          case 'metrics':
            updateMetric(data.run, data);
            break;
          case 'log':
            updateLog(data.line);
            break;
          default:
            break;
        }
      }

      const eventSource = new EventSource('/events');
      eventSource.onmessage = handleEvent;
      eventSource.onerror = () => {
        setMessage('Lost connection to live updates. Retrying…', true);
      };
    </script>
  </body>
</html>
