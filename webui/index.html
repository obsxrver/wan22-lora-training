<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WAN 2.2 LoRA Training</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #121212;
        --panel: #1f1f1f;
        --accent: #8ab4f8;
        --accent-strong: #a66bff;
        --border: #2a2a2a;
        --text: #f1f3f4;
        --muted: #9aa0a6;
      }

      body {
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        margin: 0;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
        overflow-x: hidden;
      }

      header {
        padding: 2rem 1.5rem 1rem;
        text-align: center;
        background: linear-gradient(135deg, rgba(138, 180, 248, 0.25), rgba(166, 107, 255, 0.25));
        border-bottom: 1px solid var(--border);
      }

      header h1 {
        margin: 0 0 0.5rem;
        font-size: 2rem;
      }

      header p {
        margin: 0;
        color: var(--muted);
      }

      .header-text {
        max-width: 640px;
        margin: 0 auto;
      }

      header .top-nav {
        margin-top: 1.25rem;
        display: flex;
        justify-content: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .nav-link {
        display: inline-flex;
        align-items: center;
        padding: 0.6rem 1.2rem;
        border-radius: 999px;
        text-decoration: none;
        font-weight: 600;
        color: var(--text);
        border: 1px solid transparent;
        background: rgba(138, 180, 248, 0.15);
        transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
      }

      .nav-link:hover {
        border-color: rgba(138, 180, 248, 0.4);
        background: rgba(138, 180, 248, 0.25);
      }

      .nav-link--active {
        border-color: rgba(166, 107, 255, 0.5);
        background: rgba(166, 107, 255, 0.3);
      }

      main {
        max-width: 1100px;
        margin: 0 auto;
        padding: 1.5rem;
        display: grid;
        gap: 1.5rem;
      }

      section {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1.5rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
      }

      h2 {
        margin-top: 0;
        font-size: 1.35rem;
      }

      #dropzone {
        border: 2px dashed var(--accent);
        border-radius: 16px;
        padding: 2rem;
        text-align: center;
        transition: background 0.2s ease, border-color 0.2s ease;
        cursor: pointer;
        color: var(--muted);
        font-size: 1rem;
        outline: none;
      }

      #dropzone.active {
        background: rgba(138, 180, 248, 0.12);
        border-color: var(--accent-strong);
        color: var(--text);
      }

      #dropzone:focus-visible {
        border-color: var(--accent-strong);
        box-shadow: 0 0 0 3px rgba(138, 180, 248, 0.25);
        color: var(--text);
      }

      #fileInput {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        border: 0;
        clip: rect(0, 0, 0, 0);
        overflow: hidden;
      }

      #upload-summary {
        margin-top: 1rem;
        font-size: 0.95rem;
        color: var(--muted);
      }

      #dataset-preview-section {
        margin-top: 1.5rem;
      }

      .dataset-preview-collapsible {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 0.75rem 1rem 1rem;
        background: rgba(255, 255, 255, 0.04);
      }

      .dataset-preview-collapsible summary {
        list-style: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.25rem 0;
      }

      .dataset-preview-collapsible summary::-webkit-details-marker {
        display: none;
      }

      .dataset-preview-collapsible summary:focus-visible {
        outline: 2px solid rgba(138, 180, 248, 0.6);
        border-radius: 8px;
      }

      .dataset-preview-collapsible summary::after {
        content: '▾';
        font-size: 0.9rem;
        margin-left: auto;
        color: var(--muted);
        transition: transform 0.2s ease;
      }

      .dataset-preview-collapsible[open] summary::after {
        transform: rotate(180deg);
      }

      .dataset-preview-collapsible h3 {
        margin: 0;
        font-size: 1.1rem;
      }

      .dataset-preview-hint {
        margin: 0.5rem 0 1rem;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .preset-row {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: center;
        margin-top: 0.35rem;
      }

      .preset-row input,
      .preset-row select {
        flex: 1;
        min-width: 220px;
      }

      .param-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        flex-wrap: wrap;
        margin-bottom: 0.5rem;
      }

      .param-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 0.75rem;
        margin: 0.5rem 0 1rem;
      }

      .param-card {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 0.85rem;
        background: rgba(255, 255, 255, 0.03);
      }

      .param-card label {
        font-weight: 600;
        display: block;
        margin-bottom: 0.25rem;
      }

      .param-card input,
      .param-card textarea,
      .param-card select {
        width: 100%;
        padding: 0.55rem;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: var(--bg);
        color: var(--text);
      }

      .param-card textarea {
        min-height: 70px;
        resize: vertical;
      }

      .param-card .checkbox-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .param-section-title {
        margin: 0.5rem 0 0.25rem;
        font-size: 1rem;
      }

      .hidden {
        display: none;
      }

      #dataset-preview-message {
        margin-top: 0.75rem;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .dataset-grid {
        margin-top: 1rem;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 1rem;
      }

      .dataset-card {
        border: 1px solid var(--border);
        border-radius: 12px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.04);
        display: flex;
        flex-direction: column;
        min-height: 100%;
        position: relative;
        transition: opacity 0.2s ease, transform 0.2s ease;
      }

      .dataset-card--removing {
        opacity: 0.5;
        pointer-events: none;
      }

      .dataset-card-actions {
        position: absolute;
        top: 0.6rem;
        right: 0.6rem;
        display: flex;
        gap: 0.35rem;
        z-index: 1;
      }

      .dataset-card-actions button {
        appearance: none;
        border: 1px solid rgba(138, 180, 248, 0.25);
        background: rgba(18, 18, 18, 0.65);
        color: var(--text);
        border-radius: 8px;
        padding: 0.2rem 0.55rem;
        font-size: 0.75rem;
        line-height: 1.2;
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease;
      }

      .dataset-card-actions button:hover,
      .dataset-card-actions button:focus-visible {
        border-color: rgba(138, 180, 248, 0.5);
        background: rgba(138, 180, 248, 0.3);
        outline: none;
      }

      .dataset-card-actions button:disabled {
        opacity: 0.6;
        cursor: progress;
      }

      .dataset-card-media {
        width: 100%;
        height: 180px;
        object-fit: cover;
        background: rgba(0, 0, 0, 0.35);
        display: block;
      }

      .dataset-card video.dataset-card-media {
        object-fit: cover;
        width: 100%;
        height: 100%;
      }

      .dataset-card-body {
        padding: 0.9rem;
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
      }

      .dataset-card-caption-wrapper {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }

      .dataset-card-title {
        margin: 0;
        font-weight: 600;
        font-size: 0.95rem;
        color: var(--text);
        word-break: break-word;
      }

      .dataset-card-meta {
        margin: 0;
        font-size: 0.75rem;
        color: var(--muted);
        word-break: break-word;
      }

      .dataset-card-caption {
        margin: 0;
        font-size: 0.85rem;
        color: var(--muted);
        white-space: pre-wrap;
      }

      .dataset-card-caption--empty {
        font-style: italic;
      }

      .dataset-card-caption-editor {
        display: none;
        width: 100%;
        min-height: 80px;
        padding: 0.5rem 0.65rem;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.45);
        color: var(--text);
        font-family: inherit;
        font-size: 0.85rem;
        resize: vertical;
      }

      .dataset-card--editing .dataset-card-caption {
        display: none;
      }

      .dataset-card--editing .dataset-card-caption-editor {
        display: block;
      }

      form {
        display: grid;
        gap: 1rem;
      }

      .form-row {
        display: grid;
        gap: 1rem;
      }

      .form-row.two-col {
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .advanced-settings {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 0.75rem 1rem;
        background: rgba(255, 255, 255, 0.02);
      }

      .advanced-settings summary {
        cursor: pointer;
        font-weight: 700;
        color: var(--text);
        display: flex;
        align-items: center;
        gap: 0.5rem;
        list-style: none;
      }

      .advanced-settings summary::-webkit-details-marker {
        display: none;
      }

      .advanced-settings summary::before {
        content: '\25BC';
        font-size: 0.75rem;
        transition: transform 0.2s ease;
      }

      .advanced-settings[open] summary::before {
        transform: rotate(-180deg);
      }

      .advanced-content {
        margin-top: 0.75rem;
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      }

      .advanced-content .form-row,
      .advanced-content fieldset {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 0.85rem;
        background: rgba(255, 255, 255, 0.02);
      }

      label {
        display: flex;
        flex-direction: column;
        font-weight: 600;
        color: var(--muted);
        gap: 0.4rem;
      }

      a {
        color: var(--accent);
        text-decoration: none;
      }

      a:hover {
        color: var(--accent-strong);
      }

      input[type="text"],
      input[type="number"] {
        padding: 0.6rem 0.75rem;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        font-size: 0.95rem;
      }

      input[type="checkbox"] {
        width: 1.1rem;
        height: 1.1rem;
        accent-color: var(--accent);
      }

      input[type="radio"] {
        width: 1rem;
        height: 1rem;
        accent-color: var(--accent);
      }

      .mode-fieldset {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 1rem 1.25rem;
        background: rgba(255, 255, 255, 0.04);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .mode-fieldset legend {
        padding: 0 0.35rem;
        font-weight: 700;
        color: var(--text);
      }

      .mode-options {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
      }

      .mode-option {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        font-weight: 600;
        color: var(--muted);
      }

      .mode-hint {
        margin: 0;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .toggle {
        display: flex;
        align-items: center;
        gap: 0.6rem;
        font-weight: 600;
        color: var(--muted);
      }

      .toggle.disabled {
        opacity: 0.5;
        pointer-events: none;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 0.8rem 1.4rem;
        font-size: 1rem;
        font-weight: 600;
        background: linear-gradient(135deg, var(--accent), var(--accent-strong));
        color: var(--text);
        cursor: pointer;
        transition: transform 0.15s ease, opacity 0.15s ease;
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      button:not(:disabled):hover {
        transform: translateY(-1px);
      }

      .button-secondary {
        background: linear-gradient(135deg, #ff8a80, #ff5252);
      }

      #status-line {
        font-size: 1rem;
        font-weight: 600;
        color: var(--accent);
      }

      #message {
        color: var(--muted);
        font-size: 0.95rem;
        min-height: 1.2rem;
      }

      .metrics {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .metric-card {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 1rem;
        background: rgba(255, 255, 255, 0.03);
      }

      .metric-card--disabled {
        opacity: 0.65;
        border-style: dashed;
      }

      .status-note {
        font-size: 0.9rem;
        color: var(--muted);
      }

      #cloudStatusMessage,
      #apiKeyMessage {
        min-height: 1.2rem;
      }

      .api-key-row {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-top: 0.5rem;
      }

      .api-key-row input[type="text"] {
        flex: 1;
      }

      .button-inline {
        padding: 0.6rem 1rem;
        border-radius: 12px;
        white-space: nowrap;
      }

      .metric-card h3 {
        margin: 0 0 0.5rem;
        font-size: 1.1rem;
      }

      .metric-card p {
        margin: 0.2rem 0;
        font-size: 0.95rem;
        color: var(--muted);
      }

      .metric-status {
        margin: 0.35rem 0 0.5rem;
        font-size: 0.85rem;
        color: var(--muted);
        min-height: 1.1rem;
      }

      canvas {
        width: 100% !important;
        max-height: 320px;
      }

      #logOutput {
        background: rgba(0, 0, 0, 0.35);
        border-radius: 12px;
        border: 1px solid var(--border);
        padding: 1rem;
        max-height: 280px;
        overflow-y: auto;
        font-family: "JetBrains Mono", "Fira Code", monospace;
        font-size: 0.85rem;
        line-height: 1.45;
        white-space: pre-wrap;
      }

      @media (max-width: 768px) {
        header {
          padding: 1.5rem 1rem 1rem;
        }
        main {
          padding: 1rem;
        }
        .dataset-grid {
          grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
        }
        .dataset-card-media {
          height: 150px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-text">
        <h1>WAN 2.2 LoRA Training</h1>
        <p>Upload your dataset, configure prompts, and launch training with live feedback.</p>
      </div>
      <nav class="top-nav" aria-label="Main navigation">
        <a href="/" class="nav-link nav-link--active" aria-current="page">Training UI</a>
        <a href="https://obsxrver.pro/SillyCaption" class="nav-link" target="_blank" rel="noopener">SillyCaption</a>
      </nav>
    </header>
    <main>
      <section>
        <h2>1. Upload dataset files</h2>
        <div id="dropzone" role="button" tabindex="0" aria-controls="upload-summary" aria-describedby="dropzone-instructions">
          <strong>Drop images, videos, and caption files here</strong>
          <div id="dropzone-instructions">or click to browse from your machine.</div>
        </div>
        <input id="fileInput" type="file" multiple />
        <div id="upload-summary">Files will be saved to /workspace/musubi-tuner/dataset/.</div>
        <div id="dataset-preview-section">
          <details class="dataset-preview-collapsible" open>
            <summary>
              <h3>Current Dataset</h3>
            </summary>
            <p class="dataset-preview-hint">
              Need captions? Try the <a href="https://obsxrver.pro/SillyCaption" target="_blank" rel="noopener">SillyCaption</a> tool to auto-generate captions before you start training.
            </p>
            <div id="dataset-preview-message" aria-live="polite">No dataset files uploaded yet.</div>
            <div id="dataset-grid" class="dataset-grid" role="list"></div>
          </details>
        </div>
      </section>

      <section>
        <h2>2. Configure training</h2>
        <div id="status-line">Status: <span id="status">Idle</span></div>
        <div id="message"></div>
        <form id="trainingForm">
          <div class="form-row two-col">
            <label>
              Title suffix
              <input type="text" name="titleSuffix" value="mylora" required />
            </label>
            <label>
              Author
              <input type="text" name="author" value="authorName" required />
            </label>
          </div>
          <div class="form-row">
            <label>
              Save every N epochs
              <input type="number" name="saveEvery" min="1" value="20" />
            </label>
          </div>
          <details class="advanced-settings">
            <summary>Advanced model parameters</summary>
            <div class="advanced-content">
              <div class="form-row">
                <label>
                  Dataset config path
                  <input type="text" name="datasetPath" value="/workspace/musubi-tuner/dataset/dataset.toml" required />
                </label>
              </div>
              <div class="form-row">
                <label>
                  Presets
                  <div class="preset-row">
                    <select id="presetSelect" aria-label="Preset selector"></select>
                    <button type="button" id="loadPresetButton" class="button-secondary">Load preset</button>
                  </div>
                  <div class="preset-row">
                    <input
                      type="text"
                      id="presetNameInput"
                      placeholder="Preset name, e.g. /AI_Characters"
                      autocomplete="off"
                    />
                    <button type="button" id="savePresetButton">Save current as preset</button>
                  </div>
                  <div id="presetMessage" class="status-note" aria-live="polite"></div>
                </label>
              </div>
              <div class="form-row">
                <fieldset class="mode-fieldset">
                  <legend>Task</legend>
                  <div class="mode-options" role="radiogroup" aria-label="Training task">
                    <label class="mode-option">
                      <input type="radio" name="trainingMode" value="t2v" checked />
                      <span>Text to Video (T2V)</span>
                    </label>
                    <label class="mode-option">
                      <input type="radio" name="trainingMode" value="i2v" />
                      <span>Image to Video (I2V)</span>
                    </label>
                  </div>
                </fieldset>
              </div>
              <div class="form-row">
                <fieldset class="mode-fieldset">
                  <legend>Noise schedule</legend>
                  <div class="mode-options" role="radiogroup" aria-label="Noise schedule">
                    <label class="mode-option">
                      <input type="radio" name="noiseMode" value="high" />
                      <span>High Noise Only</span>
                    </label>
                    <label class="mode-option">
                      <input type="radio" name="noiseMode" value="low" />
                      <span>Low Noise Only</span>
                    </label>
                    <label class="mode-option">
                      <input type="radio" name="noiseMode" value="both" checked />
                      <span>Both (Recommended)</span>
                    </label>
                    <label class="mode-option">
                      <input type="radio" name="noiseMode" value="combined" />
                      <span>Combined (one model)</span>
                    </label>
                  </div>
                  <p class="mode-hint">If your instance has 2 GPUs, I can train high noise and low noise simultaneously. Use combined to train one model across all timesteps.</p>
                </fieldset>
              </div>
              <div class="form-row two-col">
                <label>
                  CPU threads per process (leave blank for auto)
                  <input type="number" name="cpuThreads" min="1" placeholder="Auto" />
                </label>
                <label>
                  Max data loader workers (leave blank for auto)
                  <input type="number" name="maxWorkers" min="1" placeholder="Auto" />
                </label>
              </div>
              <div class="form-row two-col">
                <label class="toggle">
                  <input type="checkbox" name="uploadCloud" checked />
                  Upload LoRAs to cloud storage after training
                </label>
                <label class="toggle">
                  <input type="checkbox" name="shutdownInstance" checked />
                  Shut down instance after training
                </label>
              </div>
              <div class="form-row">
                <label class="toggle">
                  <input type="checkbox" name="convertVideos" />
                  Convert dataset videos to 16 FPS before training
                </label>
              </div>
              <div class="form-row">
                <div class="param-header">
                  <h3 class="param-section-title">Training parameters</h3>
                  <label class="toggle inline">
                    <input type="checkbox" id="splitParamsToggle" />
                    Use different commands for high noise
                  </label>
                </div>
                <div>
                  <h4 class="param-section-title">Shared parameters</h4>
                  <div id="sharedParams" class="param-grid"></div>
                </div>
                <div id="perNoiseParams" class="hidden">
                  <h4 class="param-section-title">High noise overrides</h4>
                  <div id="highParams" class="param-grid"></div>
                  <h4 class="param-section-title">Low noise overrides</h4>
                  <div id="lowParams" class="param-grid"></div>
                </div>
              </div>
              <div id="cloudStatusMessage" class="status-note" aria-live="polite"></div>
            </div>
          </details>
          <div class="form-row">
            <label>
              Vast.ai API key for cloud uploads
              <span class="status-note"
                >Need a key? <a href="https://cloud.vast.ai/manage-keys" target="_blank" rel="noopener">Create one on Vast.ai</a>.</span
              >
              <div class="api-key-row">
                <input type="text" id="vastApiKeyInput" placeholder="Enter Vast.ai API key" autocomplete="off" spellcheck="false" />
                <button type="button" id="saveApiKeyButton" class="button-inline">Save key</button>
              </div>
              <div id="apiKeyMessage" class="status-note" aria-live="polite"></div>
            </label>
          </div>
          <div class="form-row two-col">
            <button id="startButton" type="submit">Start training</button>
            <button id="stopButton" type="button" class="button-secondary" disabled>Stop training</button>
          </div>
        </form>
      </section>

      <section>
        <h2>3. Live progress</h2>
        <div class="metrics">
          <div class="metric-card" id="highMetrics">
            <h3>High noise</h3>
            <p class="metric-status" id="highStatus" aria-live="polite"></p>
            <p>Current step: <span id="highStep">-</span></p>
            <p>Current loss: <span id="highLoss">-</span></p>
            <p>Epoch: <span id="highEpoch">-</span></p>
            <p>Total steps: <span id="highTotalSteps">-</span></p>
            <p>Time elapsed: <span id="highElapsed">-</span></p>
            <p>Time remaining: <span id="highEta">-</span></p>
          </div>
          <div class="metric-card" id="lowMetrics">
            <h3>Low noise</h3>
            <p class="metric-status" id="lowStatus" aria-live="polite"></p>
            <p>Current step: <span id="lowStep">-</span></p>
            <p>Current loss: <span id="lowLoss">-</span></p>
            <p>Epoch: <span id="lowEpoch">-</span></p>
            <p>Total steps: <span id="lowTotalSteps">-</span></p>
            <p>Time elapsed: <span id="lowElapsed">-</span></p>
            <p>Time remaining: <span id="lowEta">-</span></p>
          </div>
        </div>
        <canvas id="lossChart"></canvas>
      </section>

      <section>
        <h2>Training log</h2>
        <pre id="logOutput">Waiting for training output…</pre>
      </section>
    </main>

    <script
      src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"
      integrity="sha384-9nhczxUqK87bcKHh20fSQcTGD4qq5GhayNYSYWqwBkINBhOfQLg/P5HG5lF1urn4"
      crossorigin="anonymous"
    ></script>
    <script>
      const dropzone = document.getElementById('dropzone');
      const fileInput = document.getElementById('fileInput');
      const uploadSummary = document.getElementById('upload-summary');
      const datasetGrid = document.getElementById('dataset-grid');
      const datasetMessage = document.getElementById('dataset-preview-message');
      const presetSelect = document.getElementById('presetSelect');
      const loadPresetButton = document.getElementById('loadPresetButton');
      const savePresetButton = document.getElementById('savePresetButton');
      const presetNameInput = document.getElementById('presetNameInput');
      const presetMessage = document.getElementById('presetMessage');
      const sharedParamsContainer = document.getElementById('sharedParams');
      const highParamsContainer = document.getElementById('highParams');
      const lowParamsContainer = document.getElementById('lowParams');
      const splitParamsToggle = document.getElementById('splitParamsToggle');
      const perNoiseParams = document.getElementById('perNoiseParams');
      const form = document.getElementById('trainingForm');
      const statusEl = document.getElementById('status');
      const messageEl = document.getElementById('message');
      const startButton = document.getElementById('startButton');
      const highStepEl = document.getElementById('highStep');
      const highLossEl = document.getElementById('highLoss');
      const highEpochEl = document.getElementById('highEpoch');
      const highTotalStepsEl = document.getElementById('highTotalSteps');
      const highElapsedEl = document.getElementById('highElapsed');
      const highEtaEl = document.getElementById('highEta');
      const highStatusEl = document.getElementById('highStatus');
      const highCardEl = document.getElementById('highMetrics');
      const highTitleEl = highCardEl ? highCardEl.querySelector('h3') : null;
      const lowStepEl = document.getElementById('lowStep');
      const lowLossEl = document.getElementById('lowLoss');
      const lowEpochEl = document.getElementById('lowEpoch');
      const lowTotalStepsEl = document.getElementById('lowTotalSteps');
      const lowElapsedEl = document.getElementById('lowElapsed');
      const lowEtaEl = document.getElementById('lowEta');
      const lowStatusEl = document.getElementById('lowStatus');
      const lowCardEl = document.getElementById('lowMetrics');
      const lowTitleEl = lowCardEl ? lowCardEl.querySelector('h3') : null;
      const stopButton = document.getElementById('stopButton');
      const logOutput = document.getElementById('logOutput');
      const uploadCloudCheckbox = form.querySelector('input[name="uploadCloud"]');
      const uploadCloudLabel = uploadCloudCheckbox ? uploadCloudCheckbox.closest('.toggle') : null;
      const cloudStatusMessageEl = document.getElementById('cloudStatusMessage');
      const apiKeyInput = document.getElementById('vastApiKeyInput');
      const apiKeyButton = document.getElementById('saveApiKeyButton');
      const apiKeyMessageEl = document.getElementById('apiKeyMessage');
      let currentCloudStatus = null;
      const DEFAULT_PRESET_NAME = '/AI_Characters';
      let hasLoadedDefaultPreset = false;
      const NO_CAPTION_TEXT = 'No caption file found for this media.';

      const MAX_LOG_LINES = 400;
      const logLines = [];
      const VIDEO_EXTENSION_PATTERN = /\.(mp4|mov|avi|mkv|webm|mpg|mpeg)$/i;
      let currentNoiseMode = 'both';
      const DEFAULT_PATHS = {
        vae: '/workspace/musubi-tuner/models/vae/split_files/vae/wan_2.1_vae.safetensors',
        t5: '/workspace/musubi-tuner/models/text_encoders/models_t5_umt5-xxl-enc-bf16.pth',
        t2vHigh: '/workspace/musubi-tuner/models/diffusion_models/split_files/diffusion_models/wan2.2_t2v_high_noise_14B_fp16.safetensors',
        t2vLow: '/workspace/musubi-tuner/models/diffusion_models/split_files/diffusion_models/wan2.2_t2v_low_noise_14B_fp16.safetensors',
        i2vHigh: '/workspace/musubi-tuner/models/diffusion_models/split_files/diffusion_models/wan2.2_i2v_high_noise_14B_fp16.safetensors',
        i2vLow: '/workspace/musubi-tuner/models/diffusion_models/split_files/diffusion_models/wan2.2_i2v_low_noise_14B_fp16.safetensors',
      };

      const PARAM_DEFINITIONS = [
        { key: 'task', label: 'Task', type: 'text' },
        { key: 'dit', label: 'DiT path', type: 'text' },
        { key: 'dit_high_noise', label: 'High noise DiT', type: 'text' },
        { key: 'vae', label: 'VAE path', type: 'text' },
        { key: 't5', label: 'T5 path', type: 'text' },
        { key: 'mixed_precision', label: 'Mixed precision', type: 'text' },
        { key: 'fp8_base', label: 'FP8 base', type: 'checkbox' },
        { key: 'fp8_scaled', label: 'FP8 scaled', type: 'checkbox' },
        { key: 'fp8_t5', label: 'FP8 T5', type: 'checkbox' },
        { key: 'optimizer_type', label: 'Optimizer type', type: 'text' },
        { key: 'learning_rate', label: 'Learning rate', type: 'number' },
        { key: 'gradient_checkpointing', label: 'Gradient checkpointing', type: 'checkbox' },
        { key: 'gradient_accumulation_steps', label: 'Gradient accumulation steps', type: 'number' },
        { key: 'max_data_loader_n_workers', label: 'Max data loader workers', type: 'number' },
        { key: 'network_module', label: 'Network module', type: 'text' },
        { key: 'network_dim', label: 'Network dim', type: 'number' },
        { key: 'network_alpha', label: 'Network alpha', type: 'number' },
        { key: 'timestep_sampling', label: 'Timestep sampling', type: 'text' },
        { key: 'discrete_flow_shift', label: 'Discrete flow shift', type: 'number' },
        { key: 'max_train_epochs', label: 'Max train epochs', type: 'number' },
        { key: 'seed', label: 'Seed', type: 'number' },
        { key: 'optimizer_args', label: 'Optimizer args', type: 'text' },
        { key: 'max_grad_norm', label: 'Max grad norm', type: 'number' },
        { key: 'lr_scheduler', label: 'LR scheduler', type: 'text' },
        { key: 'lr_scheduler_power', label: 'LR scheduler power', type: 'number' },
        { key: 'lr_scheduler_min_lr_ratio', label: 'LR min lr ratio', type: 'number' },
        { key: 'lr_warmup_steps', label: 'LR warmup steps', type: 'number' },
        { key: 'output_name', label: 'Output name', type: 'text' },
        { key: 'metadata_title', label: 'Metadata title', type: 'text' },
        { key: 'preserve_distribution_shape', label: 'Preserve distribution shape', type: 'checkbox' },
        { key: 'min_timestep', label: 'Min timestep', type: 'number' },
        { key: 'max_timestep', label: 'Max timestep', type: 'number' },
        { key: 'img_in_txt_in_offloading', label: 'img_in_txt_in_offloading', type: 'checkbox' },
        { key: 'offload_inactive_dit', label: 'Offload inactive DiT', type: 'checkbox' },
        { key: 'persistent_data_loader_workers', label: 'Persistent data loader workers', type: 'checkbox' },
        { key: 'timestep_boundary', label: 'Timestep boundary', type: 'number' },
        { key: 'vae_cache_cpu', label: 'VAE cache CPU', type: 'checkbox' },
        { key: 'vae_dtype', label: 'VAE dtype', type: 'text' },
        { key: 'sdpa', label: 'SDPA attention', type: 'checkbox' },
        { key: 'blocks_to_swap', label: 'Blocks to swap', type: 'number' },
        { key: 'network_args', label: 'Network args (one per line)', type: 'textarea' },
    ];

      function buildDefaultParams(trainingMode = 't2v') {
        const isT2V = trainingMode === 't2v';
        const shared = {
          task: isT2V ? 't2v-A14B' : 'i2v-A14B',
          vae: DEFAULT_PATHS.vae,
          t5: DEFAULT_PATHS.t5,
          mixed_precision: 'fp16',
          fp8_base: true,
          optimizer_type: 'adamw',
          learning_rate: 0.0003,
          gradient_checkpointing: true,
          gradient_accumulation_steps: 1,
          max_data_loader_n_workers: 8,
          network_module: 'networks.lora_wan',
          network_dim: 16,
          network_alpha: 16,
          timestep_sampling: 'shift',
          discrete_flow_shift: 1,
          max_train_epochs: 100,
          seed: 5,
          optimizer_args: 'weight_decay=0.1',
          max_grad_norm: 0,
          lr_scheduler: 'polynomial',
          lr_scheduler_power: 8,
          lr_scheduler_min_lr_ratio: 0.00005,
          preserve_distribution_shape: true,
          sdpa: true,
        };

        const high = {
          dit: isT2V ? DEFAULT_PATHS.t2vHigh : DEFAULT_PATHS.i2vHigh,
          min_timestep: 875,
          max_timestep: 1000,
        };

        const low = {
          dit: isT2V ? DEFAULT_PATHS.t2vLow : DEFAULT_PATHS.i2vLow,
          min_timestep: 0,
          max_timestep: 875,
        };

        return { shared, high, low };
      }

      function renderParams(container, values = {}) {
        if (!container) return;
        container.innerHTML = '';
        PARAM_DEFINITIONS.forEach((def) => {
          const card = document.createElement('div');
          card.className = 'param-card';
          card.dataset.key = def.key;

          const label = document.createElement('label');
          label.textContent = def.label;
          card.appendChild(label);

          let input;
          if (def.type === 'checkbox') {
            const wrapper = document.createElement('div');
            wrapper.className = 'checkbox-row';
            input = document.createElement('input');
            input.type = 'checkbox';
            wrapper.appendChild(input);
            wrapper.appendChild(document.createTextNode(' Enable'));
            card.appendChild(wrapper);
          } else if (def.type === 'textarea') {
            input = document.createElement('textarea');
            card.appendChild(input);
          } else {
            input = document.createElement('input');
            input.type = def.type || 'text';
            if (def.type === 'number') {
              input.step = 'any';
            }
            card.appendChild(input);
          }

          const value = values[def.key];
          if (def.type === 'checkbox') {
            input.checked = Boolean(value ?? false);
          } else if (def.type === 'textarea') {
            if (Array.isArray(value)) {
              input.value = value.join('\n');
            } else if (value !== undefined && value !== null) {
              input.value = value.toString();
            }
          } else if (value !== undefined && value !== null) {
            input.value = value;
          }

          card.appendChild(input);
          container.appendChild(card);
        });
      }

      function applyParams(container, values = {}) {
        if (!container) return;
        container.querySelectorAll('.param-card').forEach((card) => {
          const key = card.dataset.key;
          const input = card.querySelector('input, textarea');
          if (!input || !(key in values)) {
            return;
          }
          const value = values[key];
          if (input.type === 'checkbox') {
            input.checked = Boolean(value);
          } else if (input.tagName === 'TEXTAREA') {
            if (Array.isArray(value)) {
              input.value = value.join('\n');
            } else {
              input.value = value ?? '';
            }
          } else if (input.type === 'number') {
            if (value === '' || value === null || value === undefined) {
              input.value = '';
            } else {
              input.value = Number(value);
            }
          } else {
            input.value = value ?? '';
          }
        });
      }

      function collectParams(container) {
        const params = {};
        if (!container) return params;
        container.querySelectorAll('.param-card').forEach((card) => {
          const key = card.dataset.key;
          const input = card.querySelector('input, textarea');
          if (!input) {
            return;
          }
          if (input.type === 'checkbox') {
            if (input.checked) {
              params[key] = true;
            }
            return;
          }
          if (input.tagName === 'TEXTAREA') {
            const lines = input.value
              .split('\n')
              .map((line) => line.trim())
              .filter((line) => line.length > 0);
            if (lines.length) {
              params[key] = lines;
            }
            return;
          }
          const raw = input.value.trim();
          if (!raw) {
            return;
          }
          if (input.type === 'number') {
            const numeric = Number(raw);
            if (Number.isFinite(numeric)) {
              params[key] = numeric;
            }
          } else {
            params[key] = raw;
          }
        });
        return params;
      }

      function buildTrainingParamsPayload(splitCommands) {
        const shared = collectParams(sharedParamsContainer);
        const high = splitCommands ? collectParams(highParamsContainer) : {};
        const low = splitCommands ? collectParams(lowParamsContainer) : {};
        return {
          split_commands: Boolean(splitCommands),
          shared,
          high,
          low,
        };
      }

      function setSplitParamsUI(enabled) {
        if (!perNoiseParams) return;
        perNoiseParams.classList.toggle('hidden', !enabled);
      }

      function setDatasetMessage(text = '', isError = false) {
        if (!datasetMessage) {
          return;
        }
        datasetMessage.textContent = text;
        datasetMessage.style.display = text ? 'block' : 'none';
        datasetMessage.style.color = isError ? '#ff8a80' : 'var(--muted)';
      }

      async function loadFullCaption(options = {}) {
        const { card, captionElement, captionEditor, editButton } = options || {};
        if (!card || !captionEditor) {
          return false;
        }
        if (card.dataset?.captionLoaded === 'true') {
          return true;
        }
        const captionPath = card.dataset?.captionPath;
        if (!captionPath) {
          card.dataset.captionLoaded = 'true';
          return true;
        }

        const params = new URLSearchParams({ caption_path: captionPath });
        const originalLabel = editButton ? editButton.textContent : null;
        if (editButton) {
          editButton.disabled = true;
          editButton.textContent = 'Loading…';
        }

        try {
          const response = await fetch(`/dataset/caption?${params.toString()}`);
          if (!response.ok) {
            throw new Error('Failed to load caption text.');
          }
          const data = await response.json();
          const captionText = data?.caption_text ?? '';
          const captionPathResponse = data?.caption_path || '';
          captionEditor.value = captionText;
          captionEditor.rows = Math.min(8, Math.max(3, captionText.split(/\n/).length || 3));
          if (captionElement) {
            if (captionText) {
              captionElement.textContent = captionText;
              captionElement.classList.remove('dataset-card-caption--empty');
            } else {
              captionElement.textContent = NO_CAPTION_TEXT;
              captionElement.classList.add('dataset-card-caption--empty');
            }
          }
          if (captionPathResponse) {
            card.dataset.captionPath = captionPathResponse;
          } else {
            delete card.dataset.captionPath;
          }
          card.dataset.captionLoaded = 'true';
          return true;
        } catch (error) {
          setDatasetMessage(error?.message || 'Failed to load caption text.', true);
          throw error;
        } finally {
          if (editButton) {
            editButton.disabled = false;
            editButton.textContent = originalLabel ?? 'Edit';
          }
        }
      }

      function startCaptionEditing(card, editButton, captionEditor) {
        if (!card || !editButton || !captionEditor) {
          return;
        }
        card.classList.add('dataset-card--editing');
        editButton.textContent = 'Save';
        captionEditor.focus();
        const length = captionEditor.value.length;
        captionEditor.setSelectionRange(length, length);
      }

      async function saveCaptionEdit(options) {
        const { card, editButton, captionElement, captionEditor } = options || {};
        if (!card || !editButton || !captionElement || !captionEditor) {
          return;
        }
        const mediaPath = card.dataset?.mediaPath;
        if (!mediaPath) {
          return;
        }
        const payload = {
          media_path: mediaPath,
          caption_text: captionEditor.value,
        };
        const captionPath = card.dataset?.captionPath;
        if (captionPath) {
          payload.caption_path = captionPath;
        }
        editButton.disabled = true;
        editButton.textContent = 'Saving…';
        try {
          const response = await fetch('/dataset/caption', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          let result = {};
          try {
            result = await response.json();
          } catch (error) {
            result = {};
          }
          if (!response.ok) {
            const detail = result?.detail || result?.message || 'Failed to update caption.';
            throw new Error(detail);
          }
          const newCaption = result?.caption_text ?? '';
          const newCaptionPath = result?.caption_path ?? '';
          if (newCaptionPath) {
            card.dataset.captionPath = newCaptionPath;
          } else {
            delete card.dataset.captionPath;
          }
          const body = card.querySelector('.dataset-card-body');
          let captionMeta = card.querySelector('.dataset-card-meta');
          if (newCaptionPath) {
            if (!captionMeta && body) {
              captionMeta = document.createElement('p');
              captionMeta.className = 'dataset-card-meta';
              const captionWrapper = body.querySelector('.dataset-card-caption-wrapper');
              if (captionWrapper) {
                body.insertBefore(captionMeta, captionWrapper);
              } else {
                body.appendChild(captionMeta);
              }
            }
            if (captionMeta) {
              captionMeta.textContent = `Caption: ${newCaptionPath}`;
            }
          } else if (captionMeta) {
            captionMeta.remove();
          }
          captionEditor.value = newCaption;
          if (newCaption) {
            captionElement.textContent = newCaption;
            captionElement.classList.remove('dataset-card-caption--empty');
          } else {
            captionElement.textContent = NO_CAPTION_TEXT;
            captionElement.classList.add('dataset-card-caption--empty');
          }
          card.dataset.captionLoaded = 'true';
          card.classList.remove('dataset-card--editing');
          setDatasetMessage(result?.message || 'Caption updated.');
        } catch (error) {
          setDatasetMessage(error?.message || 'Failed to update caption.', true);
        } finally {
          editButton.disabled = false;
          editButton.textContent = card.classList.contains('dataset-card--editing') ? 'Save' : 'Edit';
        }
      }

      async function handleDatasetItemRemoval(mediaPath, card, button) {
        if (!mediaPath) {
          return;
        }
        const segments = mediaPath.split('/');
        const displayName = segments[segments.length - 1] || mediaPath;
        const confirmed = window.confirm(
          `Remove “${displayName}” from the dataset? This will delete the media file and its captions.`
        );
        if (!confirmed) {
          return;
        }
        if (button) {
          button.disabled = true;
        }
        if (card) {
          card.classList.add('dataset-card--removing');
        }
        try {
          const response = await fetch('/dataset/delete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ media_path: mediaPath }),
          });
          let result = {};
          try {
            result = await response.json();
          } catch (error) {
            result = {};
          }
          if (!response.ok) {
            const detail = result?.detail || result?.message || 'Failed to remove media from dataset.';
            throw new Error(detail);
          }
          const message = result?.message || `Removed “${displayName}” from the dataset.`;
          await refreshDatasetPreview({ message });
        } catch (error) {
          setDatasetMessage(error?.message || 'Failed to remove media from dataset.', true);
        } finally {
          if (button) {
            button.disabled = false;
          }
          if (card) {
            card.classList.remove('dataset-card--removing');
          }
        }
      }

      function createDatasetCard(item) {
        const card = document.createElement('article');
        card.className = 'dataset-card';
        card.setAttribute('role', 'listitem');

        const mediaPath = item?.media_path || item?.image_path || item?.video_path || '';
        card.dataset.mediaPath = mediaPath;
        if (item?.caption_path) {
          card.dataset.captionPath = item.caption_path;
        }

        let captionElement;
        let captionEditor;

        const mediaUrl = item?.media_url || item?.image_url || item?.video_url || '';
        const isVideo =
          item?.media_kind === 'video' ||
          (typeof mediaPath === 'string' && VIDEO_EXTENSION_PATTERN.test(mediaPath));

        const cacheKey = mediaPath || mediaUrl;

        let mediaElement;
        if (isVideo) {
          mediaElement = document.createElement('video');
          mediaElement.preload = 'metadata';
          mediaElement.muted = true;
          mediaElement.defaultMuted = true;
          mediaElement.loop = true;
          mediaElement.playsInline = true;
          mediaElement.setAttribute('playsinline', '');
          mediaElement.setAttribute('webkit-playsinline', '');
          mediaElement.setAttribute('muted', '');
          mediaElement.controls = true;
          mediaElement.setAttribute('controlslist', 'nodownload noremoteplayback');
          mediaElement.draggable = false;
          if (mediaUrl) {
            const cacheBuster = encodeURIComponent(cacheKey);
            mediaElement.src = `${mediaUrl}?v=${cacheBuster}`;
          }
          mediaElement.setAttribute(
            'aria-label',
            mediaPath ? `Dataset video ${mediaPath}` : 'Dataset video preview'
          );
        } else {
          mediaElement = document.createElement('img');
          mediaElement.loading = 'lazy';
          mediaElement.decoding = 'async';
          mediaElement.draggable = false;
          if (mediaUrl) {
            const cacheBuster = encodeURIComponent(cacheKey);
            mediaElement.src = `${mediaUrl}?v=${cacheBuster}`;
          }
          mediaElement.alt = mediaPath
            ? `Dataset image ${mediaPath}`
            : 'Dataset image preview';
        }
        mediaElement.className = 'dataset-card-media';
        if (mediaPath) {
          mediaElement.title = mediaPath;
        }
        card.appendChild(mediaElement);

        if (mediaPath) {
          const actions = document.createElement('div');
          actions.className = 'dataset-card-actions';

          const editButton = document.createElement('button');
          editButton.type = 'button';
          editButton.className = 'dataset-card-edit';
          editButton.textContent = 'Edit';
          editButton.addEventListener('click', async (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (!captionElement || !captionEditor) {
              return;
            }
            if (card.classList.contains('dataset-card--editing')) {
              await saveCaptionEdit({ card, editButton, captionElement, captionEditor });
            } else {
              try {
                await loadFullCaption({ card, captionElement, captionEditor, editButton });
              } catch (error) {
                return;
              }
              startCaptionEditing(card, editButton, captionEditor);
            }
          });
          actions.appendChild(editButton);

          const removeButton = document.createElement('button');
          removeButton.type = 'button';
          removeButton.className = 'dataset-card-remove';
          removeButton.textContent = 'Remove';
          removeButton.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            handleDatasetItemRemoval(mediaPath, card, removeButton);
          });
          actions.appendChild(removeButton);

          card.appendChild(actions);
        }

        const body = document.createElement('div');
        body.className = 'dataset-card-body';

        const title = document.createElement('p');
        title.className = 'dataset-card-title';
        title.textContent = mediaPath || 'Unknown file';
        body.appendChild(title);

        if (item?.caption_path) {
          const captionMeta = document.createElement('p');
          captionMeta.className = 'dataset-card-meta';
          captionMeta.textContent = `Caption: ${item.caption_path}`;
          body.appendChild(captionMeta);
        }

        const captionWrapper = document.createElement('div');
        captionWrapper.className = 'dataset-card-caption-wrapper';

        captionElement = document.createElement('p');
        captionElement.className = 'dataset-card-caption';
        if (item?.caption_text) {
          captionElement.textContent = item.caption_text;
        } else {
          captionElement.textContent = NO_CAPTION_TEXT;
          captionElement.classList.add('dataset-card-caption--empty');
        }

        captionEditor = document.createElement('textarea');
        captionEditor.className = 'dataset-card-caption-editor';
        captionEditor.value = item?.caption_text || '';
        captionEditor.rows = Math.min(8, Math.max(3, captionEditor.value.split(/\n/).length || 3));
        captionEditor.placeholder = 'Enter caption text…';
        captionEditor.spellcheck = false;
        captionEditor.setAttribute('aria-label', `Edit caption for ${mediaPath || 'this media item'}`);

        captionWrapper.appendChild(captionElement);
        captionWrapper.appendChild(captionEditor);
        body.appendChild(captionWrapper);

        card.appendChild(body);
        return card;
      }

      function renderDatasetPreview(items) {
        if (!datasetGrid) {
          return;
        }
        datasetGrid.innerHTML = '';
        if (!items?.length) {
          return;
        }
        const fragment = document.createDocumentFragment();
        items.forEach((item) => {
          fragment.appendChild(createDatasetCard(item));
        });
        datasetGrid.appendChild(fragment);
      }

      async function refreshDatasetPreview(options = {}) {
        const { message: overrideMessage = null, isError = false } = options || {};
        if (!datasetGrid || !datasetMessage) {
          return;
        }
        setDatasetMessage('Loading dataset preview…');
        datasetGrid.setAttribute('aria-busy', 'true');
        datasetGrid.innerHTML = '';
        try {
          const response = await fetch('/dataset/files');
          if (!response.ok) {
            throw new Error('Failed to fetch dataset preview');
          }
          const data = await response.json();
          const items = Array.isArray(data?.items) ? data.items : [];
          if (!items.length) {
            const emptyMessage = overrideMessage ?? 'No dataset files uploaded yet.';
            setDatasetMessage(emptyMessage, overrideMessage != null ? isError : false);
            return;
          }
          renderDatasetPreview(items);
          const totalValue = Number(data?.total);
          const total = Number.isFinite(totalValue) && totalValue >= 0 ? totalValue : items.length;
          if (overrideMessage != null) {
            setDatasetMessage(overrideMessage, isError);
          } else {
            setDatasetMessage(`Showing ${total} media file${total === 1 ? '' : 's'} from the current dataset.`);
          }
        } catch (error) {
          setDatasetMessage(error?.message || 'Failed to load dataset preview.', true);
        } finally {
          datasetGrid.removeAttribute('aria-busy');
        }
      }

      function setApiKeyMessage(text = '', isError = false) {
        if (!apiKeyMessageEl) {
          return;
        }
        apiKeyMessageEl.textContent = text;
        apiKeyMessageEl.style.color = isError ? '#ff8a80' : 'var(--muted)';
      }

      function setCloudStatusUI(status) {
        currentCloudStatus = status || null;
        if (cloudStatusMessageEl) {
          const message = status?.message || '';
          cloudStatusMessageEl.textContent = message;
          if (!status) {
            cloudStatusMessageEl.style.color = 'var(--muted)';
          } else if (status.permission_error) {
            cloudStatusMessageEl.style.color = '#ff8a80';
          } else if (status.can_upload) {
            cloudStatusMessageEl.style.color = 'var(--accent)';
          } else {
            cloudStatusMessageEl.style.color = 'var(--muted)';
          }
        }

        if (!uploadCloudCheckbox) {
          return;
        }

        const disableCheckbox = !status || status.permission_error || !status.cli_available;
        uploadCloudCheckbox.disabled = disableCheckbox;
        if (disableCheckbox) {
          uploadCloudCheckbox.checked = false;
        } else if (status && !status.has_connections) {
          uploadCloudCheckbox.checked = false;
        }

        if (uploadCloudLabel) {
          uploadCloudLabel.classList.toggle('disabled', disableCheckbox);
        }
      }

      function setPresetMessage(text, isError = false) {
        if (!presetMessage) return;
        presetMessage.textContent = text;
        presetMessage.style.color = isError ? '#ff8a80' : 'var(--muted)';
      }

      function applyPresetData(data) {
        if (!data) return;
        const presetName = data.name || '';
        if (presetSelect && presetName) {
          const match = Array.from(presetSelect.options || []).find(
            (option) => option.value.toLowerCase() === presetName.toLowerCase(),
          );
          if (match) {
            presetSelect.value = match.value;
          }
        }
        if (presetNameInput && presetName) {
          presetNameInput.value = presetName;
        }
        const mode = (data.training_mode || 't2v').toLowerCase();
        const defaults = buildDefaultParams(mode);
        const trainParams = data.train_params || {};
        const sharedParams = { ...defaults.shared, ...(trainParams.shared || {}) };
        const highParams = { ...defaults.high, ...(trainParams.high || {}) };
        const lowParams = { ...defaults.low, ...(trainParams.low || {}) };

        renderParams(sharedParamsContainer, sharedParams);
        renderParams(highParamsContainer, highParams);
        renderParams(lowParamsContainer, lowParams);

        const splitCommands = Boolean(trainParams.split_commands);
        if (splitParamsToggle) {
          splitParamsToggle.checked = splitCommands;
        }
        setSplitParamsUI(splitCommands);

        const datasetInput = form.querySelector('input[name="datasetPath"]');
        if (datasetInput && data.dataset_path) {
          datasetInput.value = data.dataset_path;
        }

        const saveInput = form.querySelector('input[name="saveEvery"]');
        const presetSaveValue = data.save_every;
        if (saveInput && presetSaveValue != null) {
          saveInput.value = presetSaveValue;
        }

        const titleInput = form.querySelector('input[name="titleSuffix"]');
        if (titleInput && data.title_suffix) {
          titleInput.value = data.title_suffix;
        }

        const authorInput = form.querySelector('input[name="author"]');
        if (authorInput && data.author) {
          authorInput.value = data.author;
        }

        const convertCheckbox = form.querySelector('input[name="convertVideos"]');
        if (convertCheckbox) {
          convertCheckbox.checked = Boolean(data.convert_videos_to_16fps);
        }

        const modeInput = form.querySelector(`input[name="trainingMode"][value="${mode}"]`);
        if (modeInput) {
          modeInput.checked = true;
        }

        const noiseMode = (data.noise_mode || 'both').toLowerCase();
        const noiseInput = form.querySelector(`input[name="noiseMode"][value="${noiseMode}"]`);
        if (noiseInput) {
          noiseInput.checked = true;
        }
        currentNoiseMode = noiseMode;
        const presetRuns =
          noiseMode === 'high'
            ? ['high']
            : noiseMode === 'low'
              ? ['low']
              : noiseMode === 'combined'
                ? ['high']
                : ['high', 'low'];
        updateActiveRuns(presetRuns);
      }

      async function refreshPresetOptions() {
        if (!presetSelect) return;
        presetSelect.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = 'Select a preset';
        presetSelect.appendChild(placeholder);
        let defaultPresetMatch = null;
        try {
          const response = await fetch('/presets');
          if (!response.ok) {
            throw new Error('Failed to load presets');
          }
          const data = await response.json();
          (data.presets || []).forEach((name) => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            presetSelect.appendChild(option);
            if (!defaultPresetMatch && name.toLowerCase() === DEFAULT_PRESET_NAME.toLowerCase()) {
              defaultPresetMatch = name;
            }
          });
          if (!hasLoadedDefaultPreset) {
            const targetPreset = defaultPresetMatch || DEFAULT_PRESET_NAME;
            if (targetPreset) {
              const matchingOption = Array.from(presetSelect.options || []).find(
                (option) => option.value.toLowerCase() === targetPreset.toLowerCase(),
              );
              if (matchingOption) {
                presetSelect.value = matchingOption.value;
                if (presetNameInput) {
                  presetNameInput.value = matchingOption.value;
                }
              } else if (presetNameInput) {
                presetNameInput.value = targetPreset;
              }
              await loadPresetByName(targetPreset);
            }
            hasLoadedDefaultPreset = true;
          }
        } catch (error) {
          setPresetMessage(error?.message || 'Failed to load presets.', true);
        }
      }

      async function loadPresetByName(name) {
        const normalized = (name || '').toString().trim();
        if (!normalized) {
          setPresetMessage('Pick a preset to load.');
          return;
        }
        if (presetSelect) {
          const match = Array.from(presetSelect.options || []).find(
            (option) => option.value.toLowerCase() === normalized.toLowerCase(),
          );
          if (match) {
            presetSelect.value = match.value;
          }
        }
        if (presetNameInput) {
          presetNameInput.value = normalized;
        }
        setPresetMessage('Loading preset…');
        const safeName = normalized.replace(/^\//, '');
        try {
          const response = await fetch(`/presets/${encodeURIComponent(safeName)}`);
          const data = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(data?.detail || 'Failed to load preset');
          }
          applyPresetData(data);
          setPresetMessage(`Loaded preset ${normalized}.`);
        } catch (error) {
          setPresetMessage(error?.message || 'Failed to load preset.', true);
        }
      }

      async function saveCurrentPreset() {
        const name = (presetNameInput?.value || '').trim();
        if (!name) {
          setPresetMessage('Enter a preset name, e.g. /AI_Characters.', true);
          return;
        }

        const datasetPath = (form.querySelector('input[name="datasetPath"]')?.value || '').trim();
        if (!datasetPath) {
          setPresetMessage('Dataset path is required to save a preset.', true);
          return;
        }

        const trainingMode = (form.querySelector('input[name="trainingMode"]:checked')?.value || 't2v').toLowerCase();
        const noiseMode = (form.querySelector('input[name="noiseMode"]:checked')?.value || 'both').toLowerCase();
        const convertVideos = form.querySelector('input[name="convertVideos"]')?.checked || false;
        const splitCommands = splitParamsToggle?.checked || false;
        const presetPayload = {
          name,
          dataset_path: datasetPath,
          training_mode: trainingMode,
          noise_mode: noiseMode,
          convert_videos_to_16fps: convertVideos,
          train_params: buildTrainingParamsPayload(splitCommands),
          title_suffix: form.querySelector('input[name="titleSuffix"]')?.value || undefined,
          author: form.querySelector('input[name="author"]')?.value || undefined,
          save_every: Number(form.querySelector('input[name="saveEvery"]')?.value || '') || undefined,
        };

        setPresetMessage('Saving preset…');
        try {
          const response = await fetch('/presets/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(presetPayload),
          });
          const data = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(data?.detail || 'Failed to save preset');
          }
          setPresetMessage('Preset saved.');
          await refreshPresetOptions();
        } catch (error) {
          setPresetMessage(error?.message || 'Failed to save preset.', true);
        }
      }

      async function refreshCloudStatus() {
        try {
          const response = await fetch('/cloud-status');
          if (!response.ok) {
            throw new Error('Failed to fetch cloud status');
          }
          const data = await response.json();
          setCloudStatusUI(data);
        } catch (error) {
          if (cloudStatusMessageEl) {
            cloudStatusMessageEl.textContent = 'Unable to determine cloud connection status.';
            cloudStatusMessageEl.style.color = '#ff8a80';
          }
          currentCloudStatus = null;
        }
      }

      async function saveApiKey() {
        if (!apiKeyInput) {
          return;
        }
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) {
          setApiKeyMessage('Enter an API key from https://cloud.vast.ai/manage-keys.', true);
          return;
        }

        if (apiKeyButton) {
          apiKeyButton.disabled = true;
        }
        setApiKeyMessage('Saving API key…');

        try {
          const response = await fetch('/vast-api-key', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ api_key: apiKey }),
          });
          const data = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(data.detail || 'Failed to save API key');
          }
          apiKeyInput.value = '';
          setApiKeyMessage(data.message || 'API key saved.');
          if (data.cloud_status) {
            setCloudStatusUI(data.cloud_status);
          } else {
            await refreshCloudStatus();
          }
        } catch (error) {
          setApiKeyMessage(error.message || 'Failed to save API key.', true);
        } finally {
          if (apiKeyButton) {
            apiKeyButton.disabled = false;
          }
        }
      }

      if (apiKeyButton) {
        apiKeyButton.addEventListener('click', saveApiKey);
      }

      if (apiKeyInput) {
        apiKeyInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            saveApiKey();
          }
        });
      }

      const runDisplays = {
        high: {
          step: highStepEl,
          loss: highLossEl,
          epoch: highEpochEl,
          total: highTotalStepsEl,
          elapsed: highElapsedEl,
          eta: highEtaEl,
          status: highStatusEl,
          card: highCardEl,
        },
        low: {
          step: lowStepEl,
          loss: lowLossEl,
          epoch: lowEpochEl,
          total: lowTotalStepsEl,
          elapsed: lowElapsedEl,
          eta: lowEtaEl,
          status: lowStatusEl,
          card: lowCardEl,
        },
      };
      const noiseModeInputs = form.querySelectorAll('input[name="noiseMode"]');

      let chart;
      let activeRuns = new Set(['high', 'low']);

      function setRunState(run, isActive, message = '') {
        const display = runDisplays[run];
        if (!display) {
          return;
        }
        if (display.card) {
          if (isActive) {
            display.card.classList.remove('metric-card--disabled');
            display.card.removeAttribute('aria-disabled');
          } else {
            display.card.classList.add('metric-card--disabled');
            display.card.setAttribute('aria-disabled', 'true');
          }
        }
        if (display.status) {
          display.status.textContent = message || '';
          display.status.style.display = message ? 'block' : 'none';
        }
      }

      function refreshNoiseLabels() {
        if (highTitleEl) {
          highTitleEl.textContent = currentNoiseMode === 'combined' ? 'Combined noise' : 'High noise';
        }
        if (lowTitleEl) {
          lowTitleEl.textContent = currentNoiseMode === 'combined' ? 'Low noise (not used)' : 'Low noise';
        }
        if (chart && chart.data && Array.isArray(chart.data.datasets)) {
          const [highDataset, lowDataset] = chart.data.datasets;
          if (highDataset) {
            highDataset.label = currentNoiseMode === 'combined' ? 'Combined noise loss' : 'High noise loss';
          }
          if (lowDataset) {
            lowDataset.label = 'Low noise loss';
          }
          chart.update('none');
        }
      }

      function updateActiveRuns(runs) {
        const normalized = Array.isArray(runs)
          ? runs
              .map((run) => {
                if (run === 'high' || run === 'low' || run === 'combined') {
                  return run;
                }
                return null;
              })
              .filter(Boolean)
          : [];
        if (!normalized.length) {
          normalized.push('high', 'low');
        }
        activeRuns = new Set(normalized);
        if (currentNoiseMode === 'combined') {
          activeRuns = new Set(['high']);
        }
        ['high', 'low'].forEach((run) => {
          const isActive = activeRuns.has(run);
          const statusText =
            currentNoiseMode === 'combined' && run === 'low'
              ? 'Combined mode trains one model for high + low noise.'
              : isActive
                ? ''
                : 'Disabled in configuration.';
          setRunState(run, isActive, statusText);
        });
        if (chart && chart.data && Array.isArray(chart.data.datasets)) {
          const datasets = chart.data.datasets;
          if (datasets[0]) {
            datasets[0].hidden = !activeRuns.has('high');
          }
          if (datasets[1]) {
            datasets[1].hidden = !activeRuns.has('low');
          }
          chart.update('none');
        }
        refreshNoiseLabels();
      }

      noiseModeInputs.forEach((input) => {
        input.addEventListener('change', () => {
          if (startButton.disabled) {
            return;
          }
          const value = (input.value || '').toLowerCase();
          currentNoiseMode = value === 'combined' ? 'combined' : value === 'high' ? 'high' : value === 'low' ? 'low' : 'both';
          const runs =
            currentNoiseMode === 'high'
              ? ['high']
              : currentNoiseMode === 'low'
                ? ['low']
                : currentNoiseMode === 'combined'
                  ? ['high']
                  : ['high', 'low'];
          updateActiveRuns(runs);
        });
      });

      refreshCloudStatus();

      function updateRunDisplay(run, current) {
        const display = runDisplays[run];
        if (!display) {
          return;
        }
        const hasData = current && typeof current === 'object';
        const stepValue = hasData && current.step != null ? current.step : '-';
        const lossValue = hasData && current.loss != null && Number.isFinite(Number(current.loss))
          ? Number(current.loss).toFixed(6)
          : '-';
        const totalValue = hasData && current.total_steps != null ? current.total_steps : '-';
        const epochValue = hasData && current.epoch != null ? current.epoch : '-';
        const totalEpochValue = hasData && current.total_epochs != null ? current.total_epochs : '-';
        let epochDisplay = '-';
        if (epochValue !== '-') {
          epochDisplay = totalEpochValue !== '-' ? `${epochValue} / ${totalEpochValue}` : `${epochValue}`;
        }
        const elapsedValue = hasData && current.time_elapsed ? current.time_elapsed : '-';
        const remainingValue = hasData && current.time_remaining ? current.time_remaining : '-';
        display.step.textContent = stepValue;
        display.loss.textContent = lossValue;
        display.epoch.textContent = epochDisplay;
        display.total.textContent = totalValue;
        display.elapsed.textContent = elapsedValue;
        display.eta.textContent = remainingValue;
      }

      function initChart() {
        const ctx = document.getElementById('lossChart').getContext('2d');
        chart = new Chart(ctx, {
          type: 'line',
          data: {
            datasets: [
              {
                label: 'High noise loss',
                data: [],
                borderColor: 'rgba(138, 180, 248, 0.95)',
                backgroundColor: 'rgba(138, 180, 248, 0.15)',
                tension: 0.2,
                pointRadius: 0,
                borderWidth: 2,
              },
              {
                label: 'Low noise loss',
                data: [],
                borderColor: 'rgba(166, 107, 255, 0.95)',
                backgroundColor: 'rgba(166, 107, 255, 0.15)',
                tension: 0.2,
                pointRadius: 0,
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            animation: false,
            maintainAspectRatio: false,
            interaction: {
              mode: 'index',
              intersect: false,
              axis: 'x',
            },
            scales: {
              x: {
                type: 'linear',
                title: { display: true, text: 'Step' },
                ticks: { color: '#bdc1c6' },
                grid: { color: 'rgba(189, 193, 198, 0.1)' },
              },
              y: {
                title: { display: true, text: 'Loss' },
                ticks: { color: '#bdc1c6' },
                grid: { color: 'rgba(189, 193, 198, 0.1)' },
              },
            },
            plugins: {
              legend: {
                labels: {
                  color: '#e8eaed',
                },
              },
              tooltip: {
                intersect: false,
                callbacks: {
                  title: (context) => {
                    if (!context?.length) {
                      return '';
                    }
                    const step = context[0].parsed?.x;
                    return Number.isFinite(step) ? `Step ${step}` : '';
                  },
                  label: (context) => {
                    const label = context.dataset?.label || '';
                    const loss = context.parsed?.y;
                    if (!Number.isFinite(loss)) {
                      return label;
                    }
                    return `${label}: ${loss.toFixed(6)}`;
                  },
                },
              },
            },
          },
        });
      }

      initChart();
      updateActiveRuns([...activeRuns]);

      refreshDatasetPreview();

      function resetChart() {
        chart.data.datasets.forEach((dataset) => {
          dataset.data = [];
        });
        chart.update('none');
        updateRunDisplay('high', null);
        updateRunDisplay('low', null);
        updateActiveRuns([...activeRuns]);
        logLines.length = 0;
        logOutput.textContent = 'Waiting for training output…';
        stopButton.disabled = true;
      }

      async function uploadFiles(fileList) {
        if (!fileList || !fileList.length) {
          return;
        }
        const formData = new FormData();
        Array.from(fileList).forEach((file) => formData.append('files', file, file.name));
        uploadSummary.textContent = 'Uploading ' + fileList.length + ' file(s)…';
        try {
          const response = await fetch('/upload', {
            method: 'POST',
            body: formData,
          });
          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.detail || 'Upload failed');
          }
          const result = await response.json();
          uploadSummary.textContent = `Uploaded ${result.count} file(s).`;
        } catch (error) {
          uploadSummary.textContent = error.message || 'Upload failed';
        } finally {
          await refreshDatasetPreview();
        }
      }

      dropzone.addEventListener('click', () => fileInput.click());
      dropzone.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          fileInput.click();
        }
      });

      ['dragenter', 'dragover'].forEach((type) => {
        dropzone.addEventListener(type, (event) => {
          event.preventDefault();
          event.dataTransfer.dropEffect = 'copy';
          dropzone.classList.add('active');
        });
      });

      dropzone.addEventListener('dragleave', (event) => {
        if (!dropzone.contains(event.relatedTarget)) {
          dropzone.classList.remove('active');
        }
      });

      document.addEventListener('dragover', (event) => {
        event.preventDefault();
      });

      document.addEventListener('drop', (event) => {
        if (!dropzone.contains(event.target)) {
          event.preventDefault();
        }
      });

      dropzone.addEventListener('mouseleave', () => {
        dropzone.classList.remove('active');
      });

      dropzone.addEventListener('drop', (event) => {
        event.preventDefault();
        dropzone.classList.remove('active');
        if (event.dataTransfer?.files?.length) {
          uploadFiles(event.dataTransfer.files);
        }
      });

      fileInput.addEventListener('change', (event) => {
        if (event.target.files?.length) {
          uploadFiles(event.target.files);
          fileInput.value = '';
        }
      });

      function initializeParamsUI() {
        const trainingMode = (form.querySelector('input[name="trainingMode"]:checked')?.value || 't2v').toLowerCase();
        const defaults = buildDefaultParams(trainingMode);
        renderParams(sharedParamsContainer, defaults.shared);
        renderParams(highParamsContainer, defaults.high);
        renderParams(lowParamsContainer, defaults.low);
        setSplitParamsUI(splitParamsToggle?.checked || false);
      }

      initializeParamsUI();
      refreshPresetOptions();

      if (splitParamsToggle) {
        splitParamsToggle.addEventListener('change', () => setSplitParamsUI(splitParamsToggle.checked));
      }

      form.querySelectorAll('input[name="trainingMode"]').forEach((input) => {
        input.addEventListener('change', () => {
          initializeParamsUI();
        });
      });

      if (loadPresetButton) {
        loadPresetButton.addEventListener('click', () => loadPresetByName(presetSelect?.value || presetNameInput?.value || ''));
      }

      if (presetSelect) {
        presetSelect.addEventListener('change', (event) => {
          if (presetNameInput && event.target.value) {
            presetNameInput.value = event.target.value;
          }
        });
      }

      if (savePresetButton) {
        savePresetButton.addEventListener('click', saveCurrentPreset);
      }

      function setStatus(text) {
        statusEl.textContent = text;
      }

      function setMessage(text, isError = false) {
        messageEl.textContent = text;
        messageEl.style.color = isError ? '#ff8a80' : 'var(--muted)';
      }

      function updateLog(line) {
        if (!line) {
          return;
        }
        logLines.push(line);
        if (logLines.length > MAX_LOG_LINES) {
          logLines.splice(0, logLines.length - MAX_LOG_LINES);
        }
        logOutput.textContent = logLines.join('\n');
        logOutput.scrollTop = logOutput.scrollHeight;
      }

      function applyHistory(datasetIndex, history) {
        const dataset = chart.data.datasets[datasetIndex];
        dataset.data = history
          .map((point) => ({ x: Number(point.step), y: Number(point.loss) }))
          .filter((point) => Number.isFinite(point.x) && Number.isFinite(point.y));
      }

      function updateMetric(run, payload) {
        const datasetIndex = run === 'high' ? 0 : 1;
        const dataset = chart.data.datasets[datasetIndex];
        if (!payload) {
          return;
        }
        let datasetUpdated = false;
        const stepValue = Number(payload.step);
        const lossValue = Number(payload.loss);
        if (Number.isFinite(stepValue) && Number.isFinite(lossValue)) {
          if (dataset.data.length && dataset.data[dataset.data.length - 1].x === stepValue) {
            dataset.data[dataset.data.length - 1].y = lossValue;
          } else {
            dataset.data.push({ x: stepValue, y: lossValue });
          }
          datasetUpdated = true;
        }
        const currentData = payload.current ? { ...payload.current } : {};
        if (!('step' in currentData) && Number.isFinite(stepValue)) {
          currentData.step = stepValue;
        }
        if (!('loss' in currentData) && Number.isFinite(lossValue)) {
          currentData.loss = lossValue;
        }
        updateRunDisplay(run, Object.keys(currentData).length ? currentData : null);
        if (datasetUpdated) {
          chart.update('none');
        }
      }

      function applySnapshot(snapshot) {
        setStatus(snapshot.status ? snapshot.status.charAt(0).toUpperCase() + snapshot.status.slice(1) : 'Idle');
        startButton.disabled = !!snapshot.running;
        stopButton.disabled = !snapshot.running;
        if (snapshot.noise_mode) {
          const noiseInput = form.querySelector(`input[name="noiseMode"][value="${snapshot.noise_mode}"]`);
          if (noiseInput) {
            noiseInput.checked = true;
          }
        }
        currentNoiseMode = snapshot.noise_mode || 'both';
        updateActiveRuns(Array.isArray(snapshot.active_runs) ? snapshot.active_runs : ['high', 'low']);
        refreshNoiseLabels();
        applyHistory(0, snapshot.high?.history || []);
        applyHistory(1, snapshot.low?.history || []);
        updateRunDisplay('high', snapshot.high?.current || null);
        updateRunDisplay('low', snapshot.low?.current || null);
        chart.update('none');
        logLines.length = 0;
        (snapshot.logs || []).forEach((line) => logLines.push(line));
        if (logLines.length) {
          logOutput.textContent = logLines.join('\n');
          logOutput.scrollTop = logOutput.scrollHeight;
        } else {
          logOutput.textContent = 'Waiting for training output…';
        }
      }

      async function startTraining(event) {
        event.preventDefault();
        const formData = new FormData(form);
        const trainingModeRaw = (formData.get('trainingMode') || 't2v').toString().toLowerCase();
        const trainingMode = trainingModeRaw === 'i2v' ? 'i2v' : 't2v';
        const noiseModeRaw = (formData.get('noiseMode') || 'both').toString().toLowerCase();
        const noiseMode =
          noiseModeRaw === 'high' || noiseModeRaw === 'low' || noiseModeRaw === 'combined' ? noiseModeRaw : 'both';
        currentNoiseMode = noiseMode;
        const selectedRuns =
          noiseMode === 'high'
            ? ['high']
            : noiseMode === 'low'
              ? ['low']
              : noiseMode === 'combined'
                ? ['high']
                : ['high', 'low'];
        const splitCommands = splitParamsToggle?.checked || false;
        const trainParams = buildTrainingParamsPayload(splitCommands);
        const payload = {
          title_suffix: (formData.get('titleSuffix') || '').toString().trim() || 'mylora',
          author: (formData.get('author') || '').toString().trim() || 'authorName',
          dataset_path: (formData.get('datasetPath') || '').toString().trim(),
          save_every: Number(formData.get('saveEvery')) || 100,
          cpu_threads_per_process: formData.get('cpuThreads') ? Number(formData.get('cpuThreads')) : null,
          max_data_loader_workers: formData.get('maxWorkers') ? Number(formData.get('maxWorkers')) : null,
          upload_cloud: formData.get('uploadCloud') === 'on',
          shutdown_instance: formData.get('shutdownInstance') === 'on',
          convert_videos_to_16fps: formData.get('convertVideos') === 'on',
          auto_confirm: true,
          training_mode: trainingMode,
          noise_mode: noiseMode,
          train_params: trainParams,
        };

        if (currentCloudStatus && !currentCloudStatus.can_upload) {
          payload.upload_cloud = false;
        }

        if (!payload.dataset_path) {
          setMessage('Dataset config path is required.', true);
          return;
        }

        resetChart();
        setMessage('Launching training…');
        startButton.disabled = true;

        try {
          const response = await fetch('/train', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.detail || 'Failed to start training');
          }
          updateActiveRuns(selectedRuns);
          setMessage('Training started. Watching logs…');
          stopButton.disabled = false;
        } catch (error) {
          startButton.disabled = false;
          setMessage(error.message || 'Failed to start training', true);
        }
      }

      form.addEventListener('submit', startTraining);

      async function stopTraining() {
        stopButton.disabled = true;
        setMessage('Stopping training…');
        try {
          const response = await fetch('/stop', { method: 'POST' });
          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.detail || 'Failed to stop training');
          }
          setMessage('Stop requested. Waiting for training to halt…');
        } catch (error) {
          setMessage(error.message || 'Failed to stop training', true);
          stopButton.disabled = false;
        }
      }

      stopButton.addEventListener('click', stopTraining);

      function handleEvent(event) {
        const data = event.data ? JSON.parse(event.data) : null;
        if (!data) return;
        switch (data.type) {
          case 'snapshot':
            applySnapshot(data);
            break;
          case 'status':
            setStatus(data.status ? data.status.charAt(0).toUpperCase() + data.status.slice(1) : 'Idle');
            startButton.disabled = !!data.running;
            stopButton.disabled = !data.running;
            if (data.status === 'failed') {
              setMessage('Training failed. See logs for details.', true);
            } else if (data.status === 'completed') {
              setMessage('Training completed successfully.');
            } else if (data.status === 'stopping') {
              setMessage('Stop requested. Waiting for training to halt…');
            } else if (data.status === 'stopped') {
              setMessage('Training stopped by user.');
            }
            break;
          case 'metrics':
            updateMetric(data.run, data);
            break;
          case 'log':
            updateLog(data.line);
            break;
          default:
            break;
        }
      }

      const eventSource = new EventSource('/events');
      eventSource.onmessage = handleEvent;
      eventSource.onerror = () => {
        setMessage('Lost connection to live updates. Retrying…', true);
      };
    </script>
  </body>
</html>
